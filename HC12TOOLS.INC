#MSG "HC12TOOLS.INC REVISION 03/27/2013"
#MSG "COPYRIGHT 2013 WILLIAM STAPLETON"
#MSG "THIS FILE MAY BE FREELY DISTRIBUTED AS LONG AS IT REMAINS UNCHANGED AND FULLY CREDITED."
#MSG "THIS LIBRARY IS INTENDED FOR USE WITH THE ASM12 ASSEMBLER PROVIDED AS PART OF"
#MSG "THE MINIIDE PROGRAM AVAILABLE FROM HTTP://WWW.MGTEK.COM/MINIIDE"
#MSG "CONDITIONAL ASSEMBLY AND MACROS MAY NOT FUNCTION IN THE CORRECT MANNER WITH OTHER ASSEMBLERS."

#INCLUDE CONSTANTS.INC			;USEFUL GLOBAL CONSTANTS
#INCLUDE SYSTEM_SELECT.INC		;BOARD-SPECIFIC OPTIONS
#INCLUDE MC9S12_REGISTERS.INC		;DEFINITIONS OF ALL SYSTEM MEMORY LOCATIONS AND CONSTANTS
#INCLUDE ASCII.INC			;DEFINITIONS OF ALL ASCII CONTROL CODES
#INCLUDE MUSIC_NOTES.INC
#INCLUDE VT100.INC

;COMMENT OUT THE FOLLOWING LINE TO INCLUDE THE FULL FILE IN THE LISTING
	NOLIST

#IF SYSTEM_OS = DBUG12
#IFNDEF LIBRARY_PAGE
LIBRARY_PAGE	EQU $3D		;D-BUG12 USES PPAGES $38, $39, $3A, $3E, AND $3F (IN VERSION 4.0)
				;PPAGES $3B, $3C, AND $3D ARE AVAILABLE SO SELECT $3D
;LIBRARY_PAGE	EQU $37		;ON DB256 PPAGES $30-$37 ARE FREE, AN OPTION WOULD PUT LIBRARY IN $37
#ENDIF
#IFNDEF LIBRARY_PAGE_LIMIT
LIBRARY_PAGE_LIMIT EQU $BFFF
#ENDIF
#ENDIF

#IF SYSTEM_OS = UBUG12 | SYSTEM_OS = SERIALMONITOR
#IFNDEF LIBRARY_PAGE
LIBRARY_PAGE	EQU $3F
#ENDIF
#IFNDEF LIBRARY_PAGE_LIMIT
LIBRARY_PAGE_LIMIT EQU $B7FF
#ENDIF
#ENDIF

#IF SYSTEM_OS = UBUG12X | SYSTEM_OS = SERIALMONITORX
#WARN "THE LIBRARY_PAGE AND LIBRARY_PAGE_LIMIT HAVE NOT BEEN VERIFIED FOR UBUG12X"
#IFNDEF LIBRARY_PAGE
LIBRARY_PAGE	EQU $37
#ENDIF
#IFNDEF LIBRARY_PAGE_LIMIT
LIBRARY_PAGE_LIMIT EQU $BFFF
#ENDIF
#ENDIF


#IFNDEF __GETC_SCI0
__GETC_SCI0	EQU	$8000
__GETS_SCI0	EQU	$8004	
__PUTC_SCI0	EQU	$8008	
__PUTS_SCI0	EQU	$800C	
__GETC_SCI1	EQU	$8010	
__GETS_SCI1	EQU	$8014	
__PUTC_SCI1	EQU	$8018	
__PUTS_SCI1	EQU	$801C	
__GETC_KEYPAD	EQU	$8020
__LCD_SETUP	EQU	$8024	
__PUTC_LCD	EQU	$8028	
__PUTS_LCD	EQU	$802C	
__PUTC_LCD_COMMAND EQU 	$8030
__SPI0_RW	EQU	$8034
__SPI0_SEND_BYTES EQU	$8038
__SPI1_RW	EQU	$803C
__SPI1_SEND_BYTES EQU	$8040
__SPI2_RW	EQU	$8044
__SPI2_SEND_BYTES EQU	$8048
__ATOI		EQU	$804C
__ATOI_2	EQU	$8050
__ATOI_16	EQU	$8054
__ITOA		EQU	$8058
__ITOA_2	EQU	$805C
__ITOA_16	EQU	$8060
__ITOA_FIXED	EQU	$8064
__ITOA_2_FIXED	EQU	$8068
__ITOA_16_FIXED	EQU	$806C
__UCASE		EQU	$8070
__LCASE		EQU	$8074
__DELAY_US	EQU	$8078
__DELAY_MS	EQU	$807C
__DELAY_S	EQU	$8080
__GETC_SCI0_NOECHO	EQU	$8084
__GETS_SCI0_NOECHO	EQU	$8088	
__GETC_SCI1_NOECHO	EQU	$808C
__GETS_SCI1_NOECHO	EQU	$8090
__PUTS_SCI_BOTH	EQU $8094
__LIBRARY_VERSION EQU 	$81FC
#ENDIF

LIBRARY_VERSION	MACRO
	CALL __LIBRARY_VERSION,LIBRARY_PAGE
	ENDM

GETC_SCI0	MACRO	;ADDRESS (OPTIONAL)
#IF \# = 0
	CALL __GETC_SCI0,LIBRARY_PAGE	;RESULT IS RETURNED IN REGISTER B
#ENDIF
#IF \# = 1			;IF A PARAMETER IS SPECIFIED IT MUST RESOLVE TO A 16-BIT ADDRESS
	PSHD
	CALL __GETC_SCI0,LIBRARY_PAGE
	STAB \1
	PULD
#ENDIF
#IF \# >1
#MSG "MACRO GETC_SCI0 ACCEPTS EITHER 0 OR 1 PARAMETERS"
#MSG "WITH 0 PARAMETERS GETC_SCI0 RETURNS A SINGLE ASCII CODE IN REGISTER B"
#MSG "WITH 1 PARAMETER, THE PARAMETER MUST RESOLVE INTO A 16-BIT ADDRESS WHERE THE ASCII CODE WILL BE STORED."
#MSG "INDEXED ADDESSES SHOULD BE ENCLOSED IN ANGLE BRACES LIKE SO: <2,X>"
#FAIL
#MEXIT
#ENDIF
	ENDM


GETC_SCI1	MACRO	;ADDRESS (OPTIONAL)
#IF \# = 0
	CALL __GETC_SCI1,LIBRARY_PAGE	;RESULT IS RETURNED IN REGISTER B
#ENDIF
#IF \# = 1			;IF A PARAMETER IS SPECIFIED IT MUST RESOLVE TO A 16-BIT ADDRESS
	PSHD
	CALL __GETC_SCI1,LIBRARY_PAGE
	STAB \1
	PULD
#ENDIF
#IF \# >1
#MSG "MACRO GETC_SCI1 ACCEPTS EITHER 0 OR 1 PARAMETERS"
#MSG "WITH 0 PARAMETERS GETC_SCI0 RETURNS A SINGLE ASCII CODE IN REGISTER B"
#MSG "WITH 1 PARAMETER, THE PARAMETER MUST RESOLVE INTO A 16-BIT ADDRESS WHERE THE ASCII CODE WILL BE STORED."
#MSG "INDEXED ADDESSES SHOULD BE ENCLOSED IN ANGLE BRACES LIKE SO: <2,X>"
#FAIL
#MEXIT
#ENDIF
	ENDM

GETS_SCI0	MACRO	;ADDRESS 
#IF \# = 1			;PARAMETER SPECIFIED MUST RESOLVE TO A 16-BIT ADDRESS
	PSHX
	LDX \1
	PSHX
	CALL __GETS_SCI0,LIBRARY_PAGE
	PULX
	PULX
#ENDIF
#IF \# != 1
#MSG "MACRO GETS_SCI0 REQUIRES 1 PARAMETER"
#MSG "THE PARAMETER MUST RESOLVE INTO A 16-BIT ADDRESS WHERE THE ASCII STRING WILL BE STORED."
#MSG "INDEXED ADDESSES SHOULD BE ENCLOSED IN ANGLE BRACES LIKE SO: <2,X>"
#FAIL
#MEXIT
#ENDIF
	ENDM

GETS_SCI1	MACRO	;ADDRESS 
#IF \# = 1			;PARAMETER SPECIFIED MUST RESOLVE TO A 16-BIT ADDRESS
	PSHX
	LDX \1
	PSHX
	CALL __GETS_SCI1,LIBRARY_PAGE
	PULX
	PULX
#ENDIF
#IF \# != 1
#MSG "MACRO GETS_SCI1 REQUIRES 1 PARAMETER"
#MSG "THE PARAMETER MUST RESOLVE INTO A 16-BIT ADDRESS WHERE THE ASCII STRING WILL BE STORED."
#MSG "INDEXED ADDESSES SHOULD BE ENCLOSED IN ANGLE BRACES LIKE SO: <2,X>"
#FAIL
#MEXIT
#ENDIF
	ENDM

GETC_SCI0_NOECHO	MACRO	;ADDRESS (OPTIONAL)
#IF \# = 0
	CALL __GETC_SCI0_NOECHO,LIBRARY_PAGE	;RESULT IS RETURNED IN REGISTER B
#ENDIF
#IF \# = 1			;IF A PARAMETER IS SPECIFIED IT MUST RESOLVE TO A 16-BIT ADDRESS
	PSHD
	CALL __GETC_SCI0_NOECHO,LIBRARY_PAGE
	STAB \1
	PULD
#ENDIF
#IF \# >1
#MSG "MACRO GETC_SCI0_NOECHO ACCEPTS EITHER 0 OR 1 PARAMETERS"
#MSG "WITH 0 PARAMETERS GETC_SCI0_NOECHO RETURNS A SINGLE ASCII CODE IN REGISTER B"
#MSG "WITH 1 PARAMETER, THE PARAMETER MUST RESOLVE INTO A 16-BIT ADDRESS WHERE THE ASCII CODE WILL BE STORED."
#MSG "INDEXED ADDESSES SHOULD BE ENCLOSED IN ANGLE BRACES LIKE SO: <2,X>"
#FAIL
#MEXIT
#ENDIF
	ENDM


GETC_SCI1_NOECHO	MACRO	;ADDRESS (OPTIONAL)
#IF \# = 0
	CALL __GETC_SCI1_NOECHO,LIBRARY_PAGE	;RESULT IS RETURNED IN REGISTER B
#ENDIF
#IF \# = 1			;IF A PARAMETER IS SPECIFIED IT MUST RESOLVE TO A 16-BIT ADDRESS
	PSHD
	CALL __GETC_SCI1_NOECHO,LIBRARY_PAGE
	STAB \1
	PULD
#ENDIF
#IF \# >1
#MSG "MACRO GETC_SCI1_NOECHO ACCEPTS EITHER 0 OR 1 PARAMETERS"
#MSG "WITH 0 PARAMETERS GETC_SCI0 RETURNS A SINGLE ASCII CODE IN REGISTER B"
#MSG "WITH 1 PARAMETER, THE PARAMETER MUST RESOLVE INTO A 16-BIT ADDRESS WHERE THE ASCII CODE WILL BE STORED."
#MSG "INDEXED ADDESSES SHOULD BE ENCLOSED IN ANGLE BRACES LIKE SO: <2,X>"
#FAIL
#MEXIT
#ENDIF
	ENDM

GETS_SCI0_NOECHO	MACRO	;ADDRESS 
#IF \# = 1			;PARAMETER SPECIFIED MUST RESOLVE TO A 16-BIT ADDRESS
	PSHX
	LDX \1
	PSHX
	CALL __GETS_SCI0_NOECHO,LIBRARY_PAGE
	PULX
	PULX
#ENDIF
#IF \# != 1
#MSG "MACRO GETS_SCI0_NOECHO REQUIRES 1 PARAMETER"
#MSG "THE PARAMETER MUST RESOLVE INTO A 16-BIT ADDRESS WHERE THE ASCII STRING WILL BE STORED."
#MSG "INDEXED ADDESSES SHOULD BE ENCLOSED IN ANGLE BRACES LIKE SO: <2,X>"
#FAIL
#MEXIT
#ENDIF
	ENDM

GETS_SCI1_NOECHO	MACRO	;ADDRESS 
#IF \# = 1			;PARAMETER SPECIFIED MUST RESOLVE TO A 16-BIT ADDRESS
	PSHX
	LDX \1
	PSHX
	CALL __GETS_SCI1_NOECHO,LIBRARY_PAGE
	PULX
	PULX
#ENDIF
#IF \# != 1
#MSG "MACRO GETS_SCI1_NOECHO REQUIRES 1 PARAMETER"
#MSG "THE PARAMETER MUST RESOLVE INTO A 16-BIT ADDRESS WHERE THE ASCII STRING WILL BE STORED."
#MSG "INDEXED ADDESSES SHOULD BE ENCLOSED IN ANGLE BRACES LIKE SO: <2,X>"
#FAIL
#MEXIT
#ENDIF
	ENDM

PUTC_SCI0	MACRO	;ADDRESS (OPTIONAL)
#IF \# = 0
	CALL __PUTC_SCI0,LIBRARY_PAGE	;RESULT IS RETURNED IN REGISTER B
#ENDIF
#IF \# = 1			;IF A PARAMETER IS SPECIFIED IT MUST RESOLVE TO A 16-BIT ADDRESS OR AN 8-BIT CONSTANT
	PSHD
	LDAB \1
	CALL __PUTC_SCI0,LIBRARY_PAGE
	PULD
#ENDIF
#IF \# >1
#MSG "MACRO PUTC_SCI0 ACCEPTS EITHER 0 OR 1 PARAMETERS"
#MSG "WITH 0 PARAMETERS PUTC_SCI0 OUTPUTS A SINGLE ASCII CODE IN REGISTER B"
#MSG "WITH 1 PARAMETER, THE PARAMETER MUST RESOLVE INTO A 16-BIT ADDRESS WHERE THE ASCII CODE IS STORED."
#MSG "INDEXED ADDESSES SHOULD BE ENCLOSED IN ANGLE BRACES LIKE SO: <2,X>"
#FAIL
#MEXIT
#ENDIF
	ENDM

PUTC_SCI1	MACRO	;ADDRESS (OPTIONAL)
#IF \# = 0
	CALL __PUTC_SCI1,LIBRARY_PAGE	;RESULT IS RETURNED IN REGISTER B
#ENDIF
#IF \# = 1			;IF A PARAMETER IS SPECIFIED IT MUST RESOLVE TO A 16-BIT ADDRESS OR AN 8-BIT CONSTANT
	PSHD
	LDAB \1
	CALL __PUTC_SCI1,LIBRARY_PAGE
	PULD
#ENDIF
#IF \# >1
#MSG "MACRO PUTC_SCI1 ACCEPTS EITHER 0 OR 1 PARAMETERS"
#MSG "WITH 0 PARAMETERS PUTC_SCI0 OUTPUTS A SINGLE ASCII CODE IN REGISTER B"
#MSG "WITH 1 PARAMETER, THE PARAMETER MUST RESOLVE INTO A 16-BIT ADDRESS WHERE THE ASCII CODE IS STORED."
#MSG "INDEXED ADDESSES SHOULD BE ENCLOSED IN ANGLE BRACES LIKE SO: <2,X>"
#FAIL
#MEXIT
#ENDIF
	ENDM

PUTS_SCI0	MACRO	;ADDRESS 
#IF \# = 1			;PARAMETER SPECIFIED MUST RESOLVE TO A 16-BIT ADDRESS
	PSHX
	LDX \1
	PSHX
	CALL __PUTS_SCI0,LIBRARY_PAGE
	PULX
	PULX
#ENDIF
#IF \# != 1
#MSG "MACRO PUTS_SCI0 REQUIRES 1 PARAMETER"
#MSG "THE PARAMETER MUST RESOLVE INTO A 16-BIT ADDRESS WHERE THE ASCII STRING IS STORED."
#MSG "INDEXED ADDESSES SHOULD BE ENCLOSED IN ANGLE BRACES LIKE SO: <2,X>"
#FAIL
#MEXIT
#ENDIF
	ENDM


PUTS_SCI1	MACRO	;ADDRESS 
#IF \# = 1			;PARAMETER SPECIFIED MUST RESOLVE TO A 16-BIT ADDRESS
	PSHX
	LDX \1
	PSHX
	CALL __PUTS_SCI1,LIBRARY_PAGE
	PULX
	PULX
#ENDIF
#IF \# != 1
#MSG "MACRO PUTS_SCI1 REQUIRES 1 PARAMETER"
#MSG "THE PARAMETER MUST RESOLVE INTO A 16-BIT ADDRESS WHERE THE ASCII STRING IS STORED."
#MSG "INDEXED ADDESSES SHOULD BE ENCLOSED IN ANGLE BRACES LIKE SO: <2,X>"
#FAIL
#MEXIT
#ENDIF
	ENDM

PUTS_SCI_BOTH	MACRO	;ADDRESS 
#IF \# = 1			;PARAMETER SPECIFIED MUST RESOLVE TO A 16-BIT ADDRESS
	PSHX
	LDX \1
	PSHX
	CALL __PUTS_SCI_BOTH,LIBRARY_PAGE
	PULX
	PULX
#ENDIF
#IF \# != 1
#MSG "MACRO PUTS_SCI_BOTH REQUIRES 1 PARAMETER"
#MSG "THE PARAMETER MUST RESOLVE INTO A 16-BIT ADDRESS WHERE THE ASCII STRING IS STORED."
#MSG "INDEXED ADDESSES SHOULD BE ENCLOSED IN ANGLE BRACES LIKE SO: <2,X>"
#FAIL
#MEXIT
#ENDIF
	ENDM

GETC	MACRO	
	GETC_SCI0 \1 \2 \3 \4 \5 \6 \7 \8 \9		;SCI0 IS DEFAULT INTERFACE
	ENDM

PUTC	MACRO	
	PUTC_SCI0 \1 \2 \3 \4 \5 \6 \7 \8 \9		;SCI0 IS DEFAULT INTERFACE
	ENDM

GETS	MACRO	
	GETS_SCI0 \1 \2 \3 \4 \5 \6 \7 \8 \9		;SCI0 IS DEFAULT INTERFACE
	ENDM

PUTS	MACRO	
	PUTS_SCI0 \1 \2 \3 \4 \5 \6 \7 \8 \9		;SCI0 IS DEFAULT INTERFACE
	ENDM


GETC_KEYPAD	MACRO	;ADDRESS (OPTIONAL)
#IF \# = 0
	CALL __GETC_KEYPAD,LIBRARY_PAGE	;RESULT IS RETURNED IN REGISTER B
#ENDIF
#IF \# = 1			;IF A PARAMETER IS SPECIFIED IT MUST RESOLVE TO A 16-BIT ADDRESS
	PSHD
	CALL __GETC_KEYPAD,LIBRARY_PAGE
	STAB \1
	PULD
#ENDIF
#IF \# >1
#MSG "MACRO GETC_KEYPAD ACCEPTS EITHER 0 OR 1 PARAMETERS"
#MSG "WITH 0 PARAMETERS GETC_KEYPAD RETURNS A SINGLE ASCII CODE IN REGISTER B"
#MSG "WITH 1 PARAMETER, THE PARAMETER MUST RESOLVE INTO A 16-BIT ADDRESS WHERE THE ASCII CODE WILL BE STORED."
#MSG "INDEXED ADDESSES SHOULD BE ENCLOSED IN ANGLE BRACES LIKE SO: <2,X>"
#FAIL
#ENDIF
	ENDM

LCD_SETUP	MACRO
	CALL __LCD_SETUP,LIBRARY_PAGE
	ENDM


PUTC_LCD	MACRO	;ADDRESS (OPTIONAL)
#IF \# = 0
	CALL __PUTC_LCD,LIBRARY_PAGE	;OUTPUT FROM REGISTER B
#ENDIF
#IF \# = 1		;IF A PARAMETER IS SPECIFIED IT MUST RESOLVE TO A 16-BIT ADDRESS OR 8-BIT CONSTANT
	PSHD
	LDAB \1
	CALL __PUTC_LCD,LIBRARY_PAGE
	PULD
#ENDIF
#IF \# >1
#MSG "MACRO PUTC_LCD ACCEPTS EITHER 0 OR 1 PARAMETERS"
#MSG "WITH 0 PARAMETERS PUTC_LCD OUTPUTS A SINGLE ASCII CODE IN REGISTER B"
#MSG "WITH 1 PARAMETER, THE PARAMETER MUST RESOLVE INTO A 16-BIT ADDRESS WHERE THE ASCII CODE IS STORED."
#MSG "INDEXED ADDESSES SHOULD BE ENCLOSED IN ANGLE BRACES LIKE SO: <2,X>"
#FAIL
#MEXIT
#ENDIF
	ENDM

PUTS_LCD	MACRO	;ADDRESS 
#IF \# = 1			;IF A PARAMETER IS SPECIFIED IT MUST RESOLVE TO A 16-BIT ADDRESS
	PSHX
	LDX \1
	PSHX
	CALL __PUTS_LCD,LIBRARY_PAGE
	PULX
	PULX
#ENDIF
#IF \# != 1
#MSG "MACRO PUTS_LCD REQUIRES 1 PARAMETER"
#MSG "THE PARAMETER MUST RESOLVE INTO A 16-BIT ADDRESS WHERE THE ASCII STRING IS STORED."
#MSG "INDEXED ADDESSES SHOULD BE ENCLOSED IN ANGLE BRACES LIKE SO: <2,X>"
#FAIL
#MEXIT
#ENDIF
	ENDM

PUTC_LCD_COMMAND	MACRO	;ADDRESS (OPTIONAL)
#IF \# = 0
	CALL __PUTC_LCD_COMMAND,LIBRARY_PAGE	;OUTPUT FROM REGISTER B
#ENDIF
#IF \# = 1		;IF A PARAMETER IS SPECIFIED IT MUST RESOLVE TO A 16-BIT ADDRESS OR 8-BIT CONSTANT
	PSHD
	LDAB \1
	CALL __PUTC_LCD_COMMAND,LIBRARY_PAGE
	PULD
#ENDIF
#IF \# >1
#MSG "MACRO PUTC_LCD_COMMAND ACCEPTS EITHER 0 OR 1 PARAMETERS"
#MSG "WITH 0 PARAMETERS PUTC_LCD OUTPUTS A SINGLE ASCII CODE IN REGISTER B"
#MSG "WITH 1 PARAMETER, THE PARAMETER MUST RESOLVE INTO A 16-BIT ADDRESS WHERE THE ASCII CODE IS STORED."
#MSG "INDEXED ADDESSES SHOULD BE ENCLOSED IN ANGLE BRACES LIKE SO: <2,X>"
#FAIL
#MEXIT
#ENDIF
	ENDM

SPI0_RW	MACRO	;ADDRESS (OPTIONAL)
#IF \# = 0
	CALL __SPI0_RW,LIBRARY_PAGE	;RESULT IS RETURNED IN REGISTER B
#ENDIF
#IF \# = 1			;IF A PARAMETER IS SPECIFIED IT MUST RESOLVE TO A 16-BIT ADDRESS
	PSHD
	LDAB \1
	CALL __SPI0_RW,LIBRARY_PAGE
	STAB \1
	PULD
#ENDIF
#IF \# >1
#MSG "MACRO SPI0_RW ACCEPTS EITHER 0 OR 1 PARAMETERS"
#MSG "WITH 0 PARAMETERS SPI0_RW EXCHANGES A SINGLE BYTE IN REGISTER B"
#MSG "WITH 1 PARAMETER, THE PARAMETER MUST RESOLVE INTO A 16-BIT ADDRESS SPECIFYING THE BYTE TO BE EXCHANGED."
#MSG "INDEXED ADDESSES SHOULD BE ENCLOSED IN ANGLE BRACES LIKE SO: <2,X>"
#FAIL
#ENDIF
	ENDM

SPI1_RW	MACRO	;ADDRESS (OPTIONAL)
#IF \# = 0
	CALL __SPI1_RW,LIBRARY_PAGE	;RESULT IS RETURNED IN REGISTER B
#ENDIF
#IF \# = 1			;IF A PARAMETER IS SPECIFIED IT MUST RESOLVE TO A 16-BIT ADDRESS
	PSHD
	LDAB \1
	CALL __SPI1_RW,LIBRARY_PAGE
	STAB \1
	PULD
#ENDIF
#IF \# >1
#MSG "MACRO SPI1_RW ACCEPTS EITHER 0 OR 1 PARAMETERS"
#MSG "WITH 0 PARAMETERS SPI0_RW EXCHANGES A SINGLE BYTE IN REGISTER B"
#MSG "WITH 1 PARAMETER, THE PARAMETER MUST RESOLVE INTO A 16-BIT ADDRESS SPECIFYING THE BYTE TO BE EXCHANGED."
#MSG "INDEXED ADDESSES SHOULD BE ENCLOSED IN ANGLE BRACES LIKE SO: <2,X>"
#FAIL
#ENDIF
	ENDM

SPI2_RW 	MACRO	;ADDRESS (OPTIONAL)
#IF \# = 0
	CALL __SPI2_RW,LIBRARY_PAGE	;RESULT IS RETURNED IN REGISTER B
#ENDIF
#IF \# = 1			;IF A PARAMETER IS SPECIFIED IT MUST RESOLVE TO A 16-BIT ADDRESS
	PSHD
	LDAB \1
	CALL __SPI2_RW,LIBRARY_PAGE
	STAB \1
	PULD
#ENDIF
#IF \# >1
#MSG "MACRO SPI2_RW ACCEPTS EITHER 0 OR 1 PARAMETERS"
#MSG "WITH 0 PARAMETERS SPI0_RW EXCHANGES A SINGLE BYTE IN REGISTER B"
#MSG "WITH 1 PARAMETER, THE PARAMETER MUST RESOLVE INTO A 16-BIT ADDRESS SPECIFYING THE BYTE TO BE EXCHANGED."
#MSG "INDEXED ADDESSES SHOULD BE ENCLOSED IN ANGLE BRACES LIKE SO: <2,X>"
#FAIL
#ENDIF
	ENDM

SPI0_SEND_BYTES	MACRO	;ADDRESS 
#IF \# = 1			;IF A PARAMETER IS SPECIFIED IT MUST RESOLVE TO A 16-BIT ADDRESS
	PSHX
	LDX \1
	PSHX
	CALL __SPI0_SEND_BYTES,LIBRARY_PAGE
	PULX
	PULX
#ENDIF
#IF \# != 1
#MSG "MACRO SPI0_SEND_BYTES REQUIRES 1 PARAMETER"
#MSG "THE PARAMETER MUST RESOLVE INTO A 16-BIT ADDRESS WHERE THE ASCII STRING WILL BE STORED."
#MSG "INDEXED ADDESSES SHOULD BE ENCLOSED IN ANGLE BRACES LIKE SO: <2,X>"
#FAIL
#ENDIF
	ENDM

SPI1_SEND_BYTES	MACRO	;ADDRESS 
#IF \# = 1			;IF A PARAMETER IS SPECIFIED IT MUST RESOLVE TO A 16-BIT ADDRESS
	PSHX
	LDX \1
	PSHX
	CALL __SPI1_SEND_BYTES,LIBRARY_PAGE
	PULX
	PULX
#ENDIF
#IF \# != 1
#MSG "MACRO SPI1_SEND_BYTES REQUIRES 1 PARAMETER"
#MSG "THE PARAMETER MUST RESOLVE INTO A 16-BIT ADDRESS WHERE THE ASCII STRING WILL BE STORED."
#MSG "INDEXED ADDESSES SHOULD BE ENCLOSED IN ANGLE BRACES LIKE SO: <2,X>"
#FAIL
#ENDIF
	ENDM

SPI2_SEND_BYTES	MACRO	;ADDRESS 
#IF \# = 1			;IF A PARAMETER IS SPECIFIED IT MUST RESOLVE TO A 16-BIT ADDRESS
	PSHX
	LDX \1
	PSHX
	CALL __SPI2_SEND_BYTES,LIBRARY_PAGE
	PULX
	PULX
#ENDIF
#IF \# != 1
#MSG "MACRO SPI2_SEND_BYTES REQUIRES 1 PARAMETER"
#MSG "THE PARAMETER MUST RESOLVE INTO A 16-BIT ADDRESS WHERE THE ASCII STRING WILL BE STORED."
#MSG "INDEXED ADDESSES SHOULD BE ENCLOSED IN ANGLE BRACES LIKE SO: <2,X>"
#FAIL
#ENDIF
	ENDM

ATOI	MACRO	;ADDRESS OR STRING, ADDRESS OF INTEGER (OPTIONAL) 
#IF \# = 1			;IF A PARAMETER IS SPECIFIED IT MUST RESOLVE TO A 16-BIT ADDRESS
	PSHX
	LDX \1
	PSHX
	CALL __ATOI,LIBRARY_PAGE
	PULX
	PULX
#ENDIF
#IF \# = 2			;IF A PARAMETER IS SPECIFIED IT MUST RESOLVE TO A 16-BIT ADDRESS
	PSHD
	PSHX
	LDX \1
	PSHX
	CALL __ATOI,LIBRARY_PAGE
	STD \2
	PULX
	PULX
	PULD
#ENDIF
#IF \# < 1 | \# > 2
#MSG "MACRO ATOI REQUIRES EITHER 1 OR 2 PARAMETERS"
#MSG "THE FIRST PARAMETER IS REQUIRED."
#MSG "THE PARAMETER MUST RESOLVE INTO A 16-BIT ADDRESS WHERE THE ASCII STRING WILL BE STORED."
#MSG "THE SECOND PARAMETER IS OPTIONAL."
#MSG "IF THE SECOND PARAMETER IS OMITTED THE INTEGER WILL BE RETURNED IN REGISTER D."
#MSG "IF THE SECOND PARAMETER IS SPECIFIED, IT MUST RESOLVE INTO A 16-BIT ADDRESS WHERE THE INTEGER WILL BE STORED."
#MSG "INDEXED ADDESSES SHOULD BE ENCLOSED IN ANGLE BRACES LIKE SO: <2,X>"
#FAIL
#ENDIF
	ENDM

ATOI_10 MACRO
	ATOI \1 \2 \3 \4 \5 \6\ 7 \8 \9
	ENDM

ATOI_2	MACRO	;ADDRESS OR STRING, ADDRESS OF INTEGER (OPTIONAL) 
#IF \# = 1			;IF A PARAMETER IS SPECIFIED IT MUST RESOLVE TO A 16-BIT ADDRESS
	PSHX
	LDX \1
	PSHX
	CALL __ATOI_2,LIBRARY_PAGE
	PULX
	PULX
#ENDIF
#IF \# = 2			;IF A PARAMETER IS SPECIFIED IT MUST RESOLVE TO A 16-BIT ADDRESS
	PSHD
	PSHX
	LDX \1
	PSHX
	CALL __ATOI_2,LIBRARY_PAGE
	STD \2
	PULX
	PULX
	PULD
#ENDIF
#IF \# < 1 | \# > 2
#MSG "MACRO ATOI_2 REQUIRES EITHER 1 OR 2 PARAMETERS"
#MSG "THE FIRST PARAMETER IS REQUIRED."
#MSG "THE PARAMETER MUST RESOLVE INTO A 16-BIT ADDRESS WHERE THE ASCII STRING WILL BE STORED."
#MSG "THE SECOND PARAMETER IS OPTIONAL."
#MSG "IF THE SECOND PARAMETER IS OMITTED THE INTEGER WILL BE RETURNED IN REGISTER D."
#MSG "IF THE SECOND PARAMETER IS SPECIFIED, IT MUST RESOLVE INTO A 16-BIT ADDRESS WHERE THE INTEGER WILL BE STORED."
#MSG "INDEXED ADDESSES SHOULD BE ENCLOSED IN ANGLE BRACES LIKE SO: <2,X>"
#FAIL
#ENDIF
	ENDM

ATOI_16	MACRO	;ADDRESS OF STRING, ADDRESS OF INTEGER (OPTIONAL) 
#IF \# = 1			;IF A PARAMETER IS SPECIFIED IT MUST RESOLVE TO A 16-BIT ADDRESS
	PSHX
	LDX \1
	PSHX
	CALL __ATOI_16,LIBRARY_PAGE
	PULX
	PULX
#ENDIF
#IF \# = 2			;IF A PARAMETER IS SPECIFIED IT MUST RESOLVE TO A 16-BIT ADDRESS
	PSHD
	PSHX
	LDX \1
	PSHX
	CALL __ATOI_16,LIBRARY_PAGE
	STD \2
	PULX
	PULX
	PULD
#ENDIF
#IF \# < 1 | \# > 2
#MSG "MACRO ATOI_16 REQUIRES EITHER 1 OR 2 PARAMETERS"
#MSG "THE FIRST PARAMETER IS REQUIRED."
#MSG "THE PARAMETER MUST RESOLVE INTO A 16-BIT ADDRESS WHERE THE ASCII STRING WILL BE STORED."
#MSG "THE SECOND PARAMETER IS OPTIONAL."
#MSG "IF THE SECOND PARAMETER IS OMITTED THE INTEGER WILL BE RETURNED IN REGISTER D."
#MSG "IF THE SECOND PARAMETER IS SPECIFIED, IT MUST RESOLVE INTO A 16-BIT ADDRESS WHERE THE INTEGER WILL BE STORED."
#MSG "INDEXED ADDESSES SHOULD BE ENCLOSED IN ANGLE BRACES LIKE SO: <2,X>"
#FAIL
#ENDIF
	ENDM

ITOA	MACRO	;16-BIT INTEGER, ADDRESS OF STRING
#IF \# = 2			;
	PSHX
	LDX \2			;ADDRESS OF STRING
	PSHX
	LDX \1			;INTEGER
	PSHX
	CALL __ITOA,LIBRARY_PAGE
	LEAS 4,SP		;CLEAR THE STACK
	PULX
#ENDIF
#IF \# != 2
#MSG "MACRO ITOA REQUIRES 2 PARAMETERS"
#MSG "THE FIRST PARAMETER MUST RESOLVE INTO A 16-BIT INTEGER."
#MSG "THE SECOND PARAMETER MUST RESOLVE INTO A 16-BIT ADDRESS WHERE THE ASCII STRING WILL BE STORED."
#MSG "INDEXED ADDESSES SHOULD BE ENCLOSED IN ANGLE BRACES LIKE SO: <2,X>"
#FAIL
#ENDIF
	ENDM

ITOA_10 MACRO
	ITOA \1 \2 \3 \4 \5 \6 \7 \8 \9
	ENDM


ITOA_2	MACRO	;16-BIT INTEGER, ADDRESS OF STRING
#IF \# = 2			;
	PSHX
	LDX \2			;ADDRESS OF STRING
	PSHX
	LDX \1			;INTEGER
	PSHX
	CALL __ITOA_2,LIBRARY_PAGE
	LEAS 4,SP		;CLEAR THE STACK
	PULX
#ENDIF
#IF \# != 2
#MSG "MACRO ITOA_2 REQUIRES 2 PARAMETERS"
#MSG "THE FIRST PARAMETER MUST RESOLVE INTO A 16-BIT INTEGER."
#MSG "THE SECOND PARAMETER MUST RESOLVE INTO A 16-BIT ADDRESS WHERE THE ASCII STRING WILL BE STORED."
#MSG "INDEXED ADDESSES SHOULD BE ENCLOSED IN ANGLE BRACES LIKE SO: <2,X>"
#FAIL
#ENDIF
	ENDM


ITOA_16	 MACRO	;16-BIT INTEGER, ADDRESS OF STRING
#IF \# = 2			;
	PSHX
	LDX \2			;ADDRESS OF STRING
	PSHX
	LDX \1			;INTEGER
	PSHX
	CALL __ITOA_16,LIBRARY_PAGE
	LEAS 4,SP		;CLEAR THE STACK
	PULX
#ENDIF
#IF \# != 2
#MSG "MACRO ITOA_16 REQUIRES 2 PARAMETERS"
#MSG "THE FIRST PARAMETER MUST RESOLVE INTO A 16-BIT INTEGER."
#MSG "THE SECOND PARAMETER MUST RESOLVE INTO A 16-BIT ADDRESS WHERE THE ASCII STRING WILL BE STORED."
#MSG "INDEXED ADDESSES SHOULD BE ENCLOSED IN ANGLE BRACES LIKE SO: <2,X>"
#FAIL
#ENDIF
	ENDM

ITOA_FIXED	MACRO	;16-BIT INTEGER, ADDRESS OF STRING
#IF \# = 2			;
	PSHX
	LDX \2			;ADDRESS OF STRING
	PSHX
	LDX \1			;INTEGER
	PSHX
	CALL __ITOA_FIXED,LIBRARY_PAGE
	LEAS 4,SP		;CLEAR THE STACK
	PULX
#ENDIF
#IF \# != 2
#MSG "MACRO ITOA_FIXED REQUIRES 2 PARAMETERS"
#MSG "THE FIRST PARAMETER MUST RESOLVE INTO A 16-BIT INTEGER."
#MSG "THE SECOND PARAMETER MUST RESOLVE INTO A 16-BIT ADDRESS WHERE THE ASCII STRING WILL BE STORED."
#MSG "INDEXED ADDESSES SHOULD BE ENCLOSED IN ANGLE BRACES LIKE SO: <2,X>"
#FAIL
#ENDIF
	ENDM

ITOA_10_FIXED MACRO
	ITOA_FIXED \1 \2 \3 \4 \5 \6 \7 \8 \9
	ENDM



ITOA_2_FIXED	MACRO	;16-BIT INTEGER, ADDRESS OF STRING
#IF \# = 2			;
	PSHX
	LDX \2			;ADDRESS OF STRING
	PSHX
	LDX \1			;INTEGER
	PSHX
	CALL __ITOA_2_FIXED,LIBRARY_PAGE
	LEAS 4,SP		;CLEAR THE STACK
	PULX
#ENDIF
#IF \# != 2
#MSG "MACRO ITOA_2_FIXED REQUIRES 2 PARAMETERS"
#MSG "THE FIRST PARAMETER MUST RESOLVE INTO A 16-BIT INTEGER."
#MSG "THE SECOND PARAMETER MUST RESOLVE INTO A 16-BIT ADDRESS WHERE THE ASCII STRING WILL BE STORED."
#MSG "INDEXED ADDESSES SHOULD BE ENCLOSED IN ANGLE BRACES LIKE SO: <2,X>"
#FAIL
#ENDIF
	ENDM

ITOA_16_FIXED	MACRO	;16-BIT INTEGER, ADDRESS OF STRING
#IF \# = 2			;
	PSHX
	LDX \2			;ADDRESS OF STRING
	PSHX
	LDX \1			;INTEGER
	PSHX
	CALL __ITOA_16_FIXED,LIBRARY_PAGE
	LEAS 4,SP		;CLEAR THE STACK
	PULX
#ENDIF
#IF \# != 2
#MSG "MACRO ITOA_16_FIXED REQUIRES 2 PARAMETERS"
#MSG "THE FIRST PARAMETER MUST RESOLVE INTO A 16-BIT INTEGER."
#MSG "THE SECOND PARAMETER MUST RESOLVE INTO A 16-BIT ADDRESS WHERE THE ASCII STRING WILL BE STORED."
#MSG "INDEXED ADDESSES SHOULD BE ENCLOSED IN ANGLE BRACES LIKE SO: <2,X>"
#FAIL
#ENDIF
	ENDM



UCASE	MACRO	;ADDRESS 
#IF \# = 1			;PARAMETER MUST RESOLVE TO A 16-BIT ADDRESS
	PSHX
	LDX \1
	PSHX
	CALL __UCASE,LIBRARY_PAGE
	PULX
	PULX
#ENDIF
#IF \# != 1
#MSG "MACRO UCASE REQUIRES 1 PARAMETER"
#MSG "THE PARAMETER MUST RESOLVE INTO A 16-BIT ADDRESS WHERE THE ASCII STRING WILL BE STORED."
#MSG "INDEXED ADDESSES SHOULD BE ENCLOSED IN ANGLE BRACES LIKE SO: <2,X>"
#FAIL
#ENDIF
	ENDM

LCASE	MACRO	;ADDRESS 
#IF \# = 1			;PARAMETER MUST RESOLVE TO A 16-BIT ADDRESS
	PSHX
	LDX \1
	PSHX
	CALL __LCASE,LIBRARY_PAGE
	PULX
	PULX
#ENDIF
#IF \# != 1
#MSG "MACRO LCASE REQUIRES 1 PARAMETER"
#MSG "THE PARAMETER MUST RESOLVE INTO A 16-BIT ADDRESS WHERE THE ASCII STRING WILL BE STORED."
#MSG "INDEXED ADDESSES SHOULD BE ENCLOSED IN ANGLE BRACES LIKE SO: <2,X>"
#FAIL
#ENDIF
	ENDM

DELAY_BY_US	MACRO	;COUNT
#IF \# != 1
#MSG "MACRO DELAY_BY_US REQUIRES EXACTLY 1 PARAMETER WHICH RESOLVES INTO A 16-BIT NUMBER FOR A COUNT OF MICROSECONDS TO DELAY"
#MSG "INDEXED ADDESSES SHOULD BE ENCLOSED IN ANGLE BRACES LIKE SO: <2,X>"
#FAIL
#ENDIF
	PSHX
	LDX \1
	CALL __DELAY_US,LIBRARY_PAGE
	PULX
	ENDM

DELAY_BY_MS	MACRO	;COUNT
#IF \# != 1
#MSG "MACRO DELAY_BY_MS REQUIRES EXACTLY 1 PARAMETER WHICH RESOLVES INTO A 16-BIT NUMBER FOR A COUNT OF MILLISECONDS TO DELAY"
#MSG "INDEXED ADDESSES SHOULD BE ENCLOSED IN ANGLE BRACES LIKE SO: <2,X>"
#FAIL
#ENDIF
	PSHX
	LDX \1
	CALL __DELAY_MS,LIBRARY_PAGE
	PULX
	ENDM	

DELAY_BY_S	MACRO	;COUNT
#IF \# != 1
#MSG "MACRO DELAY_BY_S REQUIRES EXACTLY 1 PARAMETER WHICH RESOLVES INTO A 16-BIT NUMBER FOR A COUNT OF SECONDS TO DELAY"
#MSG "INDEXED ADDESSES SHOULD BE ENCLOSED IN ANGLE BRACES LIKE SO: <2,X>"
#FAIL
#ENDIF
	PSHX
	LDX \1
	CALL __DELAY_S,LIBRARY_PAGE
	PULX
	ENDM	

LCD_CURSOR	MACRO	;ROW,COLUMN
#IFNDEF LCD_ROW_OFFSET
LCD_ROW_OFFSET EQU $40
#ENDIF
#IFNDEF LCD_COLUMNS
LCD_COLUMNS	EQU	16
#ENDIF
#IF \# = 2
LCD_ROW_\@	EQU \1
LCD_COL_\@	EQU \2
#IF LCD_COL_\@ >= LCD_COLUMNS
#WARN "SPECIFIED LCD COLUMN OUTSIDE OF LCD SIZE"
#ENDIF
#IF LCD_ROW_\@ > 3
#WARN "SPECIFIED LCD ROW OUTSIDE OF LCD SIZE"
#ENDIF
#IF LCD_ROW_\@ = 0
LCD_CMD_\@ EQU $80+LCD_COL_\@
#ENDIF
#IF LCD_ROW_\@ = 1
LCD_CMD_\@ EQU $80+LCD_ROW_OFFSET+LCD_COL_\@
#ENDIF
#IF LCD_ROW_\@ = 2
LCD_CMD_\@ EQU $80+LCD_COLUMNS+LCD_COL_\@
#ENDIF
#IF LCD_ROW_\@ = 3
LCD_CMD_\@ EQU $80+LCD_COLUMNS+LCD_ROW_OFFSET+LCD_COL_\@
#ENDIF
	PUTC_LCD_COMMAND #LCD_CMD_\@
#ENDIF
#IF \# != 2
#MSG "MACRO LCD_CURSOR REQUIRES EXACTLY 2 PARAMETERS WHICH RESOLVE INTO NUMBERS FOR CURSOR ROW AND COLUMN"
#MSG "BOTH ROW AND COLUMN NUMBER BEGIN WITH 0 FOR THE TOP-LEFT CORNER"
#ENDIF
	ENDM

SCI0_SPEED	MACRO ;BAUD
#IF \# = 0
BAUD_DIVISOR_\@	EQU	24000000/(16*9600)	;DEFAULT BAUD RATE IS 9600
#MSG "NO BAUD RATE SPECIFIED, USING 9600 FOR DEFAULT"
#ENDIF
#IF \# > 0
BAUD_DIVISOR_\@	EQU	24000000/(16*(\1))	;FIRST PARAMETER IS BAUD RATE
#ENDIF
#IF BAUD_DIVISOR_\@ >= BIT13
#WARN CALCULATED BAUD RATE DIVISOR IS OVER THE LIMIT, ONLY THE LOW 13 BITS WILL BE USED"
#ENDIF
	MOVW #BAUD_DIVISOR_\@, SCI0BAUD
#IF \# >1
#MSG "MACRO SCI0_SPEED EXPECTS EITHER AT MOST 1 PARAMETER WHICH WILL RESOLVE TO A BAUD RATE"
#MSG "IF NO PARAMETER IS SPECIFIED, THEN THE DEFAULT RATE OF 9600 IS USED"
#ENDIF
	ENDM

SCI0_ENABLE	MACRO 
	BSET SCI0CR2,SCI_TE+SCI_RE	;SCI TRANSMIT ENABLE AND RECEIVE ENABLE
	ENDM

SCI0_DISABLE	MACRO 
	BCLR SCI0CR2,SCI_TE+SCI_RE	;SCI TRANSMIT ENABLE AND RECEIVE ENABLE
	ENDM

SCI0_SET8N1	MACRO
	BCLR SCI0CR1,SCI_M+SCI_PE+SCI_PT
	ENDM

SCI0_SETUP	MACRO	;BAUD
	SCI0_SPEED \1
	SCI0_SET8N1
	SCI0_ENABLE
	ENDM


SCI1_SPEED	MACRO ;BAUD
#IFDEF SCI1BAUD
#IF \# = 0
BAUD_DIVISOR_\@	EQU	24000000/(16*9600)	;DEFAULT BAUD RATE IS 9600
#MSG "NO BAUD RATE SPECIFIED, USING 9600 FOR DEFAULT"
#ENDIF
#IF \# > 0
BAUD_DIVISOR_\@	EQU	24000000/(16*(\1))	;FIRST PARAMETER IS BAUD RATE
#ENDIF
#IF BAUD_DIVISOR_\@ >= BIT13
#WARN CALCULATED BAUD RATE DIVISOR IS OVER THE LIMIT, ONLY THE LOW 13 BITS WILL BE USED"
#ENDIF
	MOVW #BAUD_DIVISOR_\@, SCI1BAUD
#IF \# >1
#MSG "MACRO SCI1_SPEED EXPECTS EITHER AT MOST 1 PARAMETER WHICH WILL RESOLVE TO A BAUD RATE"
#MSG "IF NO PARAMETER IS SPOECIFIED, THEN THE DEFAULT RATE OF 9600 IS USED"
#ENDIF
#ELSE
#WARN "THE SPECIFIED HARDWARE IS NOT SUPPORTED UNDER THE SELECTED SYSTEM_BOARD"
#FAIL
#ENDIF
	ENDM

SCI1_ENABLE	MACRO 
#IFDEF SCI1CR2
	BSET SCI1CR2,SCI_TE+SCI_RE	;SCI TRANSMIT ENABLE AND RECEIVE ENABLE
#ELSE
#WARN "THE SPECIFIED HARDWARE IS NOT SUPPORTED UNDER THE SELECTED SYSTEM_BOARD"
#FAIL
#ENDIF
	ENDM

SCI1_DISABLE	MACRO 
#IFDEF SCI1CR2
	BCLR SCI1CR2,SCI_TE+SCI_RE	;SCI TRANSMIT ENABLE AND RECEIVE ENABLE
#ELSE
#WARN "THE SPECIFIED HARDWARE IS NOT SUPPORTED UNDER THE SELECTED SYSTEM_BOARD"
#FAIL
#ENDIF
	ENDM

SCI1_SET8N1	MACRO
#IFDEF SCI1CR2
	BCLR SCI1CR1,SCI_M+SCI_PE+SCI_PT
#ELSE
#WARN "THE SPECIFIED HARDWARE IS NOT SUPPORTED UNDER THE SELECTED SYSTEM_BOARD"
#FAIL
#ENDIF
	ENDM

SCI1_SETUP	MACRO	;BAUD
	SCI1_SPEED \1
	SCI1_SET8N1
	SCI1_ENABLE
	ENDM

PWM_CLOCK_DIVISORS	MACRO	;A,B,SA,SB
#IF \# >= 2
#IF \1 > 7 | \2 > 7
#WARN "CLOCK A AND B DIVISORS MUST BE SPECIFIED IN THE RANGE 0-7"
#FAIL
#ENDIF
AB_BAUD_\@	EQU (16*(\2)+\1)
	MOVB #AB_BAUD_\@,PWMPRCLK
#ENDIF
#IF \# >= 3
	MOVB #\3,PWMSCLA
#ENDIF
#IF \# >= 4
	MOVB #\4,PWMSCLB
#ENDIF
#IF \# < 2
#MSG "MACRO PWM_CLOCK_DIVISORS EXPECTS EITHER 2 OR 4 PARAMETERS."
#MSG "THE FIRST TWO PARAMETERS ARE THE SCALE FACTORS FOR PWM CLOCKS A AND B RESPECTIVELY.  THESE ARE SPECIFIED IN THE RANGE 0-7."
#MSG "THE RESULTING SCALES FOR PWM CLOCKS A AND B ARE 2^0 - 2^7."
#MSG "THE THIRD AND FOURTH PARAMETERS ARE THE PWM CLOCK SA AND SB SCALES RESPECTIVELY.  THESE ARE SPECIFIED IN THE RANGE 0-255."
#WARN "SPECIFYING LESS THAN 2 PARAMETERS RESULTS IN NO UPDATES TO THE PWM CLOCK SCALE FACTORS."
#ENDIF
	ENDM

PWM_ENABLE	MACRO	;CHANNEL
#IF \# = 1
#IF \1 <= 7
	BSET PWME,BIT\1
#ELSE
#WARN "PWM CHANNELS ARE NUMBERED 0-7."
#FAIL
#ENDIF 
#ENDIF

#IF \# = 0 | \# > 1
#WARN "MACRO PWM_ENABLE EXPECTS 1 PARAMETER SPECIFYING THE PWM CHANNEL NUMBER (0-7) TO ENABLE."
#ENDIF
	ENDM

PWM_DISABLE	MACRO	;CHANNEL
#IF \# = 1
#IF \1 <= 7
	BCLR PWME,BIT\1
#ELSE
#WARN "PWM CHANNELS ARE NUMBERED 0-7."
#FAIL
#ENDIF 
#ENDIF

#IF \# = 0 | \# > 1
#WARN "MACRO PWM_DISABLE EXPECTS 1 PARAMETER SPECIFYING THE PWM CHANNEL NUMBER (0-7) TO DISABLE."
#ENDIF
	ENDM

PWM_CLOCK_SELECT	MACRO	;CHANNEL, USE_EXTENDED_CLOCK
#IF \# = 2
#IF \1 <= 7
#IF \2 = TRUE
	BSET PWMCLK,BIT\1
#ELIF \2 = FALSE
	BCLR PWMCLK,BIT\1
#ELSE
#WARN "THE PARAMETER USE_EXTENDED_CLOCK MUST EVALUATE EITHER AS TRUE (1) OR FALSE (1)"
#FAIL
ENDIF
#ELSE
#WARN "PWM CHANNELS ARE NUMBERED 0-7."
#FAIL
#ENDIF 
#ENDIF

#IF \# < 2 | \# > 2
#WARN "MACRO PWM_CLOCK_SELECT EXPECTS 2 PARAMETERS"
#WARN "THE FIRST PARAMETER SPECIFIES THE PWM CHANNEL NUMBER (0-7) TO ENABLE."
#WARN "THE SECOND PARAMETER SPECIFIES WHETHER OR NOT TO USE TO THE EXTENDED_CLOCK AND MUST EVALUATE AS EITHER TRUE (1) OR FALSE (0)" 
#FAIL
#ENDIF
	ENDM

PWM_POLARITY_SELECT	MACRO	;CHANNEL, ACTIVE_POLARITY
#IF \# = 2
#IF \1 <= 7
#IF \2 = TRUE
	BSET PWMPOL,BIT\1
#ELIF \2 = FALSE
	BCLR PWMPOL,BIT\1
#ELSE
#WARN "THE PARAMETER ACTIVE_POLARITY MUST EVALUATE EITHER AS TRUE (1) OR FALSE (1)"
#FAIL
ENDIF
#ELSE
#WARN "PWM CHANNELS ARE NUMBERED 0-7."
#FAIL
#ENDIF 
#ENDIF

#IF \# < 2 | \# > 2
#WARN "MACRO PWM_POLARITY_SELECT EXPECTS 2 PARAMETERS"
#WARN "THE FIRST PARAMETER SPECIFIES THE PWM CHANNEL NUMBER (0-7) TO ENABLE."
#WARN "THE SECOND PARAMETER SPECIFIES ACTIVE POLARITY AND MUST EVALUATE AS EITHER TRUE (1) OR FALSE (0)" 
#FAIL
#ENDIF
	ENDM

PWM_SET_PERIOD	MACRO	;CHANNEL, PERIOD_COUNT, A_B_SCALE, SA_SB_SCALE
#IF \# = 2
PERIOD_\@	EQU \2
#ENDIF
#IF \# = 3
#IF \3 <= 7
PERIOD_\@	EQU	(\2)/(BIT\3)
#ELSE
#WARN "IF SPECIFIED THE A_B_SCALE FACTOR MUST BE IN THE RANGE 0-7"
#FAIL
#ENDIF
#ENDIF
#IF \# = 4
#IF \3 <= 7 $ \4 <= 255 $ \4 >0
PERIOD_\@	EQU	(\2)/((BIT\3)*(\4))
#ELIF \3 <= 7 $ \4 = 0
PERIOD_\@	EQU	(\2)/((BIT\3)*(256))
#ELSE
#WARN "IF SPECIFIED, THE A_B_SCALE FACTOR MUST BE IN THE RANGE 0-7"
#WARN "IF SPECIFIED, THE SA_SB_SCALE FACTOR MUST BE IN THE RANGE 0-255"
#FAIL
#ENDIF
#ENDIF

#IF \# >= 2
#IF \1 <= 7
	MOVB #PERIOD_\@, PWMPER\1
#ELSE
#WARN "PWM CHANNELS ARE NUMBERED 0-7."
#FAIL
#ENDIF 
#ENDIF

#IF \# < 2 | \# > 4
#WARN "MACRO PWM_SET_PERIOD EXPECTS 2-4 PARAMETERS"
#WARN "THE FIRST PARAMETER SPECIFIES THE PWM CHANNEL NUMBER (0-7) TO ENABLE."
#WARN "THE SECOND PARAMETER SPECIFIES THE TOTAL PWM PERIOD IN CLOCK CYCLES. IF ONLY TWO PARAMETERS ARE SPECIFIED, THIS IS PLACED DIRECTLY IN THE PERIOD REGISTER."
#WARN "IF SPECIFIED, THE THIRD PARAMETER IS THE CLOCK A OR B SCALE FACTOR (0-7).  THE PWM PERIOD IS SCALED AND THE SCALED QUANTITY IS STORED IN THE PERIOD REGISTER." 
#WARN "IF SPECIFIED, THE FOURTH PARAMETER IS THE CLOCK SA OR DB SCALE FACTOR (0-7).  THE PWM PERIOD IS SCALED BY BOTH SCALE FACTORS AND THE SCALED QUANTITY IS STORED IN THE PERIOD REGISTER." 
#FAIL
#ENDIF
	ENDM

PWM_SET_DUTY	MACRO	;CHANNEL, DUTY_COUNT, A_B_SCALE, SA_SB_SCALE
#IF \# = 2
DUTY_\@	EQU \2
#ENDIF
#IF \# = 3
#IF \3 <= 7
DUTY_\@	EQU	(\2)/(BIT\3)
#ELSE
#WARN "IF SPECIFIED THE A_B_SCALE FACTOR MUST BE IN THE RANGE 0-7"
#FAIL
#ENDIF
#ENDIF
#IF \# = 4
#IF \3 <= 7 $ \4 <= 255
DUTY_\@	EQU	(\2)/((BIT\3)*(\4))
#ELSE
#WARN "IF SPECIFIED, THE A_B_SCALE FACTOR MUST BE IN THE RANGE 0-7"
#WARN "IF SPECIFIED, THE SA_SB_SCALE FACTOR MUST BE IN THE RANGE 0-255"
#FAIL
#ENDIF
#ENDIF

#IF \# >= 2
#IF \1 <= 7
	MOVB #DUTY_\@, PWMDTY\1
#ELSE
#WARN "PWM CHANNELS ARE NUMBERED 0-7."
#FAIL
#ENDIF 
#ENDIF

#IF \# < 2 | \# > 4
#WARN "MACRO PWM_SET_DUTY EXPECTS 2-4 PARAMETERS"
#WARN "THE FIRST PARAMETER SPECIFIES THE PWM CHANNEL NUMBER (0-7) TO ENABLE."
#WARN "THE SECOND PARAMETER SPECIFIES THE TOTAL PWM ACTIVE TIME (DUTY CYCLE) IN CLOCK CYCLES. IF ONLY TWO PARAMETERS ARE SPECIFIED, THIS IS PLACED DIRECTLY IN THE PERIOD REGISTER."
#WARN "IF SPECIFIED, THE THIRD PARAMETER IS THE CLOCK A OR B SCALE FACTOR (0-7).  THE PWM PERIOD IS SCALED AND THE SCALED QUANTITY IS STORED IN THE PERIOD REGISTER." 
#WARN "IF SPECIFIED, THE FOURTH PARAMETER IS THE CLOCK SA OR DB SCALE FACTOR (0-7).  THE PWM PERIOD IS SCALED BY BOTH SCALE FACTORS AND THE SCALED QUANTITY IS STORED IN THE PERIOD REGISTER." 
#FAIL
#ENDIF
	ENDM

TIMER_SYSTEM_ENABLE	MACRO
	BSET TSCR1,TSCR1_TEN+TSCR1_TFFCA
	ENDM

TIMER_SYSTEM_DISABLE	MACRO
	BCLR TSCR1,TSCR1_TEN
	ENDM

PRINTF_DBUG12	MACRO	;FORMAT_STRING_POINTER, DATA_1, DATA_2, ...
#IF SYSTEM_OS = DBUG12	;ALL ROUTINES WITH THE SUFFIX "_DBUG12" ARE DEFINED AS PART OF THE D-BUG12 OS
#IF \# > 0
	PSHX
	PSHD	;SAVE REGISTERS
#IF \# > 35
#WARN "MAXIMUM NUMBER OF MACRO PARAMETERS IS 36"
#ENDIF
#IF \# >= 35
	LDX \Z
	PSHX
#ENDIF
#IF \# >= 34
	LDX \Y
	PSHX
#ENDIF
#IF \# >= 33
	LDX \X
	PSHX
#ENDIF
#IF \# >= 32
	LDX \W
	PSHX
#ENDIF
#IF \# >= 31
	LDX \V
	PSHX
#ENDIF
#IF \# >= 30
	LDX \U
	PSHX
#ENDIF
#IF \# >= 29
	LDX \T
	PSHX
#ENDIF
#IF \# >= 28
	LDX \S
	PSHX
#ENDIF
#IF \# >= 27
	LDX \R
	PSHX
#ENDIF
#IF \# >= 26
	LDX \Q
	PSHX
#ENDIF
#IF \# >= 25
	LDX \P
	PSHX
#ENDIF
#IF \# >= 24
	LDX \O
	PSHX
#ENDIF
#IF \# >= 23
	LDX \N
	PSHX
#ENDIF
#IF \# >= 22
	LDX \M
	PSHX
#ENDIF
#IF \# >= 21
	LDX \L
	PSHX
#ENDIF
#IF \# >= 20
	LDX \K
	PSHX
#ENDIF
#IF \# >= 19
	LDX \J
	PSHX
#ENDIF
#IF \# >= 18
	LDX \I
	PSHX
#ENDIF
#IF \# >= 17
	LDX \H
	PSHX
#ENDIF
#IF \# >= 16
	LDX \G
	PSHX
#ENDIF
#IF \# >= 15
	LDX \F
	PSHX
#ENDIF
#IF \# >= 14
	LDX \E
	PSHX
#ENDIF
#IF \# >= 13
	LDX \D
	PSHX
#ENDIF
#IF \# >= 12
	LDX \C
	PSHX
#ENDIF
#IF \# >= 11
	LDX \B
	PSHX
#ENDIF
#IF \# >= 10
	LDX \A
	PSHX
#ENDIF
#IF \# >= 9
	LDX \9
	PSHX
#ENDIF
#IF \# >= 8
	LDX \8
	PSHX
#ENDIF
#IF \# >= 7
	LDX \7
	PSHX
#ENDIF
#IF \# >= 6
	LDX \6
	PSHX
#ENDIF
#IF \# >= 5
	LDX \5
	PSHX
#ENDIF
#IF \# >= 4
	LDX \4
	PSHX
#ENDIF
#IF \# >= 3
	LDX \3
	PSHX
#ENDIF
#IF \# >= 2
	LDX \2
	PSHX
#ENDIF
	LDD \1
	JSR [PRINTF,PCR]
	LEAS ((2*(\#))-2),SP	;CLEAR THE STACK
	PULD	;RESTORE REGISTERS
	PULX
#ENDIF

#IF \# = 0
#WARN "MACRO PRINTF_DBUG12 EXPECTS 1 OR MORE PARAMETERS"
#WARN "THE FIRST PARAMETER SPECIFIES THE STARTING ADDRESS OF THE NULL-TERMINATED FORMAT STRING."
#WARN "ADDITIONAL PARAMTERS SHOULD RESOLOVE TO THE DATA TO BE INCORPORATED INTO THE FORMATTED OUTPUT IN THE ORDER IT SHOULD APPEAR."
#FAIL
#ENDIF
#ELSE
#WARN "THE SPECIFIED ROUTINE REQUIRES THE SYSTEM_OS TO BE DBUG12"
#ENDIF
	ENDM

GETCHAR_DBUG12	MACRO	;ADDRESS (OPTIONAL)
#IF SYSTEM_OS = DBUG12
#IF \# = 0
	JSR [GETCHAR,PCR]	;RESULT IS RETURNED IN REGISTER B
#ENDIF
#IF \# = 1			;IF A PARAMETER IS SPECIFIED IT MUST RESOLVE TO A 16-BIT ADDRESS
	PSHD
	JSR [GETCHAR,PCR]	;RESULT IS RETURNED IN REGISTER B
	STAB \1
	PULD
#ENDIF
#IF \# >1
#MSG "MACRO GETCHAR_DBUG12 ACCEPTS EITHER 0 OR 1 PARAMETERS"
#MSG "WITH 0 PARAMETERS GETCHAR_DBUG12 RETURNS A SINGLE ASCII CODE IN REGISTER B"
#MSG "WITH 1 PARAMETER, THE PARAMETER MUST RESOLVE INTO A 16-BIT ADDRESS WHERE THE ASCII CODE WILL BE STORED."
#MSG "INDEXED ADDESSES SHOULD BE ENCLOSED IN ANGLE BRACES LIKE SO: <2,X>"
#FAIL
#ENDIF
#ELSE
#WARN "THE SPECIFIED ROUTINE REQUIRES THE SYSTEM_OS TO BE DBUG12"
#ENDIF
	ENDM	

PUTCHAR_DBUG12	MACRO	;ADDRESS (OPTIONAL)
#IF SYSTEM_OS = DBUG12
#IF \# = 0
	JSR [PUTCHAR,PCR]	;OUTPUT FROM REGISTER B
#ENDIF
#IF \# = 1			;IF A PARAMETER IS SPECIFIED IT MUST RESOLVE TO A 16-BIT ADDRESS OR AN 8-BIT CONSTANT
	PSHD
	LDAB \1
	JSR [PUTCHAR,PCR]	;OUTPUT FROM REGISTER B
	PULD
#ENDIF
#IF \# >1
#MSG "MACRO PUTCHAR_DBUG12 ACCEPTS EITHER 0 OR 1 PARAMETERS"
#MSG "WITH 0 PARAMETERS PUTCHAR_DBUG12 OUTPUTS A SINGLE ASCII CODE IN REGISTER B"
#MSG "WITH 1 PARAMETER, THE PARAMETER MUST RESOLVE INTO A 16-BIT ADDRESS WHERE THE ASCII CODE IS STORED."
#MSG "INDEXED ADDESSES SHOULD BE ENCLOSED IN ANGLE BRACES LIKE SO: <2,X>"
#FAIL
#ENDIF
#ELSE
#WARN "THE SPECIFIED ROUTINE REQUIRES THE SYSTEM_OS TO BE DBUG12"
#ENDIF
	ENDM

GETCMDLINE_DBUG12	MACRO	;ADDRESS, LENGTH
#IF SYSTEM_OS = DBUG12
#IF \# = 2			;PARAMETER SPECIFIED MUST RESOLVE TO A 16-BIT ADDRESS
	PSHX
	PSHD
	LDX \2
	PSHX
	LDD \1
	CALL [GETCMDLINE,PCR]
	PULX
	PULD
	PULX
#ENDIF
#IF \# != 2
#MSG "MACRO GETCMDLINE_DBUG12 REQUIRES 2 PARAMETERS"
#MSG "THE FIRST PARAMETER MUST RESOLVE INTO A 16-BIT ADDRESS WHERE THE ASCII STRING WILL BE STORED."
#MSG "INDEXED ADDESSES SHOULD BE ENCLOSED IN ANGLE BRACES LIKE SO: <2,X>"
#MSG "THE SECOND PARAMETER MUST RESOLVE TO THE MAXIMUM LENGTH OF THE STRING"
#FAIL
#ENDIF
#ELSE
#WARN "THE SPECIFIED ROUTINE REQUIRES THE SYSTEM_OS TO BE DBUG12"
#ENDIF
	ENDM

STRLEN_DBUG12	MACRO	;ADDRESS 
#IF SYSTEM_OS = DBUG12
#IF \# = 1			;PARAMETER MUST RESOLVE TO A 16-BIT ADDRESS OF A NULL-TERMINATED STRING
	LDD \1
	JSR [STRLEN,PCR]	;RESULT IS RETURNED IN REGISTER D
#ENDIF
#IF \# != 1
#MSG "MACRO STRLEN_DBUG12 REQUIRES 1 PARAMETER"
#MSG "THE PARAMETER MUST RESOLVE INTO A 16-BIT ADDRESS WHERE THE NULL-TERMINATED ASCII STRING IS STORED."
#MSG "INDEXED ADDESSES SHOULD BE ENCLOSED IN ANGLE BRACES LIKE SO: <2,X>"
#FAIL
#ENDIF
#ELSE
#WARN "THE SPECIFIED ROUTINE REQUIRES THE SYSTEM_OS TO BE DBUG12"
#ENDIF
	ENDM	

STRCPY_DBUG12	MACRO	;DESTINATION_ADDRESS, SOURCE_ADDRESS
#IF SYSTEM_OS = DBUG12
#IF \# = 2			;2 PARAMETERS MUST BOTH RESOLVE TO A 16-BIT ADDRESS OF A NULL-TERMINATED STRING
	PSHX
	PSHD
	LDX \2			;ADDRESS OF SOURCE STRING
	PSHX
	LDD \1			;ADDRESS OF DESTINATION STRING
	JSR [STRCPY,PCR]	;COPY SOURCE STRING TO DESTINATION STRING
	PULX
	PULD
	PULX
#ENDIF
#IF \# != 2
#MSG "MACRO STRCPY_DBUG12 REQUIRES 2 PARAMETERS"
#MSG "THE FIRST PARAMETER MUST RESOLVE INTO A 16-BIT ADDRESS WHERE THE NULL-TERMINATED ASCII DESTINATION STRING IS TO BE STORED."
#MSG "THE SECOND PARAMETER MUST RESOLVE INTO A 16-BIT ADDRESS WHERE THE NULL-TERMINATED ASCII SOURCE STRING IS STORED."
#MSG "INDEXED ADDESSES SHOULD BE ENCLOSED IN ANGLE BRACES LIKE SO: <2,X>"
#FAIL
#ENDIF
#ELSE
#WARN "THE SPECIFIED ROUTINE REQUIRES THE SYSTEM_OS TO BE DBUG12"
#ENDIF
	ENDM	


RATIO_TO_ASCII	MACRO	;NUMERATOR, DENOMINATOR, STRING_ADDRESS
#IF \# = 3
	PSHX			;SAVE REGISTERS
	PSHY
	PSHD
				;CONVERT REMAINDER/COUNT INTO FRACTION/10000 TO OUTPUT FOUR FRACTIONAL DIGITS IN DECIMAL
	LDD \1			;NUMERATOR	
	LDY #10000
	EMUL			;10000*NUMERATOR
	LDX \2			;DENOMINATOR			
	EDIV			;10000*NUMERATOR/DENOMINATOR
	PSHY
	LEAY 0,SP
	ITOA_FIXED <0,Y>,\3	;CONVERT INTEGER TO STRING AT OUTPUT ADDRESS
	PULY
	LDX \3
	MOVB #'.', 0,X		;CONVERT FIRST '0' IN 5 DIGITS TO '.' SO THIS LOOKS LIKE A FRACTION

	PULD			;RESTORE REGISTERS
	PULY
	PULX


#ENDIF
#IF \# != 3
#MSG "MACRO RATIO_TO_ASCII REQUIRES 3 PARAMETERS TO GENERATE A DECIMAL STRING OF FOUR FRACTIONAL DIGITS FOLLOWING A DECIMAL POINT"
#MSG "THE FIRST PARAMETER MUST RESOLVE INTO A 16-BIT INTEGER WHICH IS THE NUMERATOR."
#MSG "THE SECOND PARAMETER MUST RESOLVE INTO A 16-BIT INTEGER WHICH IS THE DENOMINATOR"
#MSG "THE THIRD PARAMETER MUST RESOLVE INTO A 16-BIT ADDRESS WHERE THE ASCII STRING WILL BE STORED."
#MSG "INDEXED ADDESSES SHOULD BE ENCLOSED IN ANGLE BRACES LIKE SO: <2,X>"
#FAIL
#ENDIF
	ENDM

PSHI	MACRO	;IMMEDIATE
#IF \# = 1
	MOVW \1, 2,-SP		;PUSH IMMEDIATE VALUE ONTO STACK
#ENDIF
#IF \# != 1
#MSG "MACRO PSHI REQUIRES 1 PARAMETER"
#MSG "THE FIRST PARAMETER MUST RESOLVE INTO A 16-BIT INTEGER WHICH WILL BE PUSHED ON THE STACK."
#FAIL
#ENDIF	
	ENDM

PSHWORD 	MACRO	;IMMEDIATE
#IF \# = 1
	MOVW \1, 2,-SP		;PUSH WORD-LENGTH IMMEDIATE VALUE ONTO STACK
#ENDIF
#IF \# != 1
#MSG "MACRO PSHWORD REQUIRES 1 PARAMETER"
#MSG "THE FIRST PARAMETER MUST RESOLVE INTO A 16-BIT INTEGER WHICH WILL BE PUSHED ON THE STACK."
#FAIL
#ENDIF	
	ENDM

PSHW 	MACRO	;IMMEDIATE
#IF \# = 1
	MOVW \1, 2,-SP		;PUSH WORD-LENGTH IMMEDIATE VALUE ONTO STACK
#ENDIF
#IF \# != 1
#MSG "MACRO PSHWORD REQUIRES 1 PARAMETER"
#MSG "THE FIRST PARAMETER MUST RESOLVE INTO A 16-BIT INTEGER WHICH WILL BE PUSHED ON THE STACK."
#FAIL
#ENDIF	
	ENDM

PSHBYTE 	MACRO	;IMMEDIATE
#IF \# = 1
	MOVB \1, 1,-SP		;PUSH BYTE-LENGTH IMMEDIATE VALUE ONTO STACK
#ENDIF
#IF \# != 1
#MSG "MACRO PSHBYTE REQUIRES 1 PARAMETER"
#MSG "THE FIRST PARAMETER MUST RESOLVE INTO A 8-BIT INTEGER WHICH WILL BE PUSHED ON THE STACK."
#FAIL
#ENDIF	
	ENDM

PSH 	MACRO	;IMMEDIATE
#IF \# = 1
	MOVB \1, 1,-SP		;PUSH BYTE-LENGTH IMMEDIATE VALUE ONTO STACK
#ENDIF
#IF \# != 1
#MSG "MACRO PSHBYTE REQUIRES 1 PARAMETER"
#MSG "THE FIRST PARAMETER MUST RESOLVE INTO A 8-BIT INTEGER WHICH WILL BE PUSHED ON THE STACK."
#FAIL
#ENDIF	
	ENDM

LCD_HOME	MACRO
	PUTC_LCD_COMMAND #$80
	ENDM

LCD_ADDRESS	MACRO
	PUTC_LCD_COMMAND #($80+\1)	
	ENDM
	
CMPD	MACRO		;MACRO TO ADD ALTERNAME MNEMONIC
	CPD \1 \2
	ENDM

CMPY	MACRO		;MACRO TO ADD ALTERNAME MNEMONIC
	CPY \1 \2
	ENDM

CMPX	MACRO		;MACRO TO ADD ALTERNAME MNEMONIC
	CPX \1 \2
	ENDM

CMPS	MACRO		;MACRO TO ADD ALTERNAME MNEMONIC
	CPS \1 \2
	ENDM

XORA	MACRO		;MACRO TO ADD ALTERNAME MNEMONIC
	EORA \1 \2
	ENDM

XORB	MACRO		;MACRO TO ADD ALTERNAME MNEMONIC
	EORB \1 \2
	ENDM

;LDA, LDB, STA, AND STB ARE SUPPORTED NATIVELY BY MINIIDE
;LDA	MACRO		;MACRO TO ADD ALTERNAME MNEMONIC
;	LDAA \1 \2
;	ENDM

;LDB	MACRO		;MACRO TO ADD ALTERNAME MNEMONIC 
;	LDAB	\1 \2
;	ENDM

;STA	MACRO 		;MACRO TO ADD ALTERNAME MNEMONIC
;	STAA \1 \2
;	ENDM

;STB	MACRO		;MACRO TO ADD ALTERNAME MNEMONIC
;	STAB \1 \2
;	ENDM

INCD	MACRO		;MACRO TO ADD NEW INSTRUCTION VARIANT FOR DIFFERENT REGISTER
	ADDD #1
	ENDM

INCX	MACRO		;MACRO TO ADD ALTERNAME MNEMONIC
	INX
	ENDM

INCY	MACRO		;MACRO TO ADD ALTERNAME MNEMONIC
	INY
	ENDM
	
INCS	MACRO		;MACRO TO ADD ALTERNAME MNEMONIC
	INS
	ENDM
	
DECD	MACRO		;MACRO TO ADD NEW INSTRUCTION VARIANT FOR DIFFERENT REGISTER
	SUBD #1
	ENDM

DECX	MACRO		;MACRO TO ADD ALTERNAME MNEMONIC
	DEX
	ENDM

DECY	MACRO		;MACRO TO ADD ALTERNAME MNEMONIC
	DEY
	ENDM
	
DECS	MACRO		;MACRO TO ADD ALTERNAME MNEMONIC
	DES
	ENDM

CLRD	MACRO		;MACRO TO ADD NEW INSTRUCTION VARIANT FOR DIFFERENT REGISTER
	LDD #0
	ENDM

CLRX	MACRO		;MACRO TO ADD NEW INSTRUCTION VARIANT FOR DIFFERENT REGISTER
	LDX #0
	ENDM

CLRY	MACRO		;MACRO TO ADD NEW INSTRUCTION VARIANT FOR DIFFERENT REGISTER
	LDY #0
	ENDM

ORA	MACRO		;MACRO TO ADD ALTERNAME MNEMONIC
	ORAA \1 \2
	ENDM

ORB	MACRO		;MACRO TO ADD ALTERNAME MNEMONIC
	ORAB \1 \2
	ENDM

ASRD	MACRO		;MACRO TO ADD NEW INSTRUCTION VARIANT FOR DIFFERENT REGISTER
	ASRA
	RORB
	PSHD			;SAVE RESULT
	PSHC			;SAVE FLAGS ON STACK
	;AT THIS POINT C FLAG IS CORRECT, N, V, Z ARE NOT 
	BCLR 0,SP, CCR_V+CCR_N+CCR_Z
	;ASRD SHOULD NEVER CAUSE OVERFLOW SO CLEAR V ON STACK COPY
	;ALSO CLEAR N AND Z FOR NOW AND CORRECT THEM AS NECESSARY
	CMPD #0
	TFR CCR,A			;COPY OF CCR WITH N AND Z CORRECT
	ANDA #CCR_N+CCR_Z	;MASK ONLY N AND Z BITS
	ORAA 0,SP			;OR WITH STACK COPY
	STAA 0,SP			;REPLACE STACK COPY WITH CORRECTED COPY
	PULC				;PLACE CORRECTED FLAGS INTO CCR
	PULD				;RESTORE RESULT TO D
	ENDM

NOT	MACRO		;MACRO TO ADD ALTERNAME MNEMONIC
	COM \1 \2
	ENDM

NOTA	MACRO		;MACRO TO ADD ALTERNAME MNEMONIC
	COMA
	ENDM

NOTB MACRO		;MACRO TO ADD ALTERNAME MNEMONIC
	COMB
	ENDM

COMD MACRO		;MACRO TO ADD NEW INSTRUCTION VARIANT FOR DIFFERENT REGISTER
	COMB	
	COMA
	PSHD			;SAVE RESULT
	PSHC			;SAVE FLAGS ON STACK
	;AT THIS POINT N, Z, V ,AND C FLAGS ARE INCORRECT 
	BCLR 0,SP, CCR_V+CCR_N+CCR_Z
	;COMD SHOULD NEVER CAUSE OVERFLOW SO CLEAR V ON STACK COPY
	;ALSO CLEAR N AND Z FOR NOW AND CORRECT THEM AS NECESSARY
	BSET 0,SP, CCR_C	
	;COMD SHOULD ALWAYS SET C FLAG
	CMPD #0
	TFR CCR,A			;COPY OF CCR WITH N AND Z CORRECT
	ANDA #CCR_N+CCR_Z	;MASK ONLY N AND Z BITS
	ORAA 0,SP			;OR WITH STACK COPY
	STAA 0,SP			;REPLACE STACK COPY WITH CORRECTED COPY
	PULC				;PLACE CORRECTED FLAGS INTO CCR
	PULD				;RESTORE RESULT TO D	
	ENDM

NOTD MACRO		;MACRO TO ADD ALTERNAME MNEMONIC
	COMD
	ENDM

NEGD MACRO		;MACRO TO ADD NEW INSTRUCTION VARIANT FOR DIFFERENT REGISTER
	COMD
	INCD
	PSHD			;SAVE RESULT
	PSHC			;SAVE FLAGS ON STACK
	;AT THIS POINT V FLAG IS INCORRECT 
	BCLR 0,SP, CCR_V
	;NEGD SHOULD ONLY CAUSE OVERFLOW IF RESULT IS $8000
	;START WITH ASSUMPTION OF V=0
	CMPD #$8000
	BNE NEGD_1\@
	BSET 0,SP, CCR_V	;IF RESULT OF NEGD=$8000 THEN OVERFLOW
NEGD_1\@:
	PULC				;PLACE CORRECTED FLAGS INTO CCR
	PULD				;RESTORE RESULT TO D	
	ENDM

COMX MACRO		;MACRO TO ADD NEW INSTRUCTION VARIANT FOR DIFFERENT REGISTER
	EXG D,X
	COMD
	EXG D,X
	ENDM

NOTX MACRO		;MACRO TO ADD ALTERNAME MNEMONIC
	COMX
	ENDM

COMY MACRO		;MACRO TO ADD NEW INSTRUCTION VARIANT FOR DIFFERENT REGISTER
	EXG D,Y
	COMD
	EXG D,Y
	ENDM

NOTY MACRO		;MACRO TO ADD ALTERNAME MNEMONIC
	COMY
	ENDM

NEGX MACRO		;MACRO TO ADD NEW INSTRUCTION VARIANT FOR DIFFERENT REGISTER
	EXG D,X
	NEGD
	EXG D,X
	ENDM

NEGY MACRO		;MACRO TO ADD NEW INSTRUCTION VARIANT FOR DIFFERENT REGISTER
	EXG D,Y
	NEGD
	EXG D,Y
	ENDM

LSRX MACRO		;MACRO TO ADD NEW INSTRUCTION VARIANT FOR DIFFERENT REGISTER
	EXG D,X
	LSRD
	EXG D,X
	ENDM

LSRY MACRO		;MACRO TO ADD NEW INSTRUCTION VARIANT FOR DIFFERENT REGISTER
	EXG D,Y
	LSRD
	EXG D,Y
	ENDM

LSLX MACRO		;MACRO TO ADD NEW INSTRUCTION VARIANT FOR DIFFERENT REGISTER
	EXG D,X
	LSLD
	EXG D,X
	ENDM

LSLY MACRO		;MACRO TO ADD NEW INSTRUCTION VARIANT FOR DIFFERENT REGISTER
	EXG D,Y
	LSLD
	EXG D,Y
	ENDM

ASRX MACRO		;MACRO TO ADD NEW INSTRUCTION VARIANT FOR DIFFERENT REGISTER
	EXG D,X
	ASRD
	EXG D,X
	ENDM

ASRY MACRO		;MACRO TO ADD NEW INSTRUCTION VARIANT FOR DIFFERENT REGISTER
	EXG D,Y
	ASRD
	EXG D,Y
	ENDM

ASLX MACRO		;MACRO TO ADD NEW INSTRUCTION VARIANT FOR DIFFERENT REGISTER
	EXG D,X
	ASLD
	EXG D,X
	ENDM

ASLY MACRO		;MACRO TO ADD NEW INSTRUCTION VARIANT FOR DIFFERENT REGISTER
	EXG D,Y
	ASLD
	EXG D,Y
	ENDM

RORD MACRO		;MACRO TO ADD NEW INSTRUCTION VARIANT FOR DIFFERENT REGISTER
	PSHD		;SAVE TWO COPIES OF ORIGINAL D ON STACK
	PSHD
	RORA
	RORB
	PSHC			;SAVE FLAGS ON STACK	
	STD 3,SP		;SAVE RESULT OVER ONE COPY OF ORIGINAL D ON STACK
	;AT THIS POINT N, Z, AND V FLAGS ARE INCORRECT, C IS CORRECT 
	BCLR 0,SP, CCR_V+CCR_N+CCR_Z
	;CLEAR N, V, AND Z FOR NOW AND CORRECT THEM AS NECESSARY
	CMPD #0
	TFR CCR,A			;COPY OF CCR WITH N AND Z CORRECT
	ANDA #CCR_N+CCR_Z	;MASK ONLY N AND Z BITS
	ORAA 0,SP			;OR WITH STACK COPY
	STAA 0,SP			;REPLACE STACK COPY WITH CORRECTED COPY
	LDAA 1,SP			;LOAD UPPER BYTE OF ORIGINAL D
	EORA 3,SP			;EXCLUSIVE-OR WITH UPPER BYTE OF RESULT 
	ANDA #BIT7			;MASK OFF ONLY BIT7 (SIGN BIT)
	CMPA #0				;IF SIGN BIT UNCHANGED (I.E. EOR=0) THEN V=0
	BEQ RORD_1\@		
	BSET 0,SP, CCR_V	;SET V IF SIGN BIT CHANGED
RORD_1\@:
	PULC				;PLACE CORRECTED FLAGS INTO CCR
	PULD				;CLEAR ORIGINAL D FROM STACK
	PULD				;RESTORE RESULT TO D	
	ENDM

ROLD MACRO		;MACRO TO ADD NEW INSTRUCTION VARIANT FOR DIFFERENT REGISTER
	PSHD		;SAVE TWO COPIES OF ORIGINAL D ON STACK
	PSHD
	ROLB
	ROLA
	PSHC			;SAVE FLAGS ON STACK	
	STD 3,SP		;SAVE RESULT OVER ONE COPY OF ORIGINAL D ON STACK
	;AT THIS POINT N, Z, AND V FLAGS ARE INCORRECT, C IS CORRECT 
	BCLR 0,SP, CCR_V+CCR_N+CCR_Z
	;CLEAR N, V, AND Z FOR NOW AND CORRECT THEM AS NECESSARY
	CMPD #0
	TFR CCR,A			;COPY OF CCR WITH N AND Z CORRECT
	ANDA #CCR_N+CCR_Z	;MASK ONLY N AND Z BITS
	ORAA 0,SP			;OR WITH STACK COPY
	STAA 0,SP			;REPLACE STACK COPY WITH CORRECTED COPY
	LDAA 1,SP			;LOAD UPPER BYTE OF ORIGINAL D
	EORA 3,SP			;EXCLUSIVE-OR WITH UPPER BYTE OF RESULT 
	ANDA #BIT7			;MASK OFF ONLY BIT7 (SIGN BIT)
	CMPA #0				;IF SIGN BIT UNCHANGED (I.E. EOR=0) THEN V=0
	BEQ ROLD_1\@		
	BSET 0,SP, CCR_V	;SET V IF SIGN BIT CHANGED
ROLD_1\@:
	PULC				;PLACE CORRECTED FLAGS INTO CCR
	PULD				;CLEAR ORIGINAL D FROM STACK
	PULD				;RESTORE RESULT TO D	
	ENDM

RORX MACRO		;MACRO TO ADD NEW INSTRUCTION VARIANT FOR DIFFERENT REGISTER
	EXG D,X
	RORD
	EXG D,X
	ENDM

RORY MACRO		;MACRO TO ADD NEW INSTRUCTION VARIANT FOR DIFFERENT REGISTER
	EXG D,Y
	RORD
	EXG D,Y
	ENDM

ROLX MACRO		;MACRO TO ADD NEW INSTRUCTION VARIANT FOR DIFFERENT REGISTER
	EXG D,X
	ROLD
	EXG D,X
	ENDM

ROLY MACRO		;MACRO TO ADD NEW INSTRUCTION VARIANT FOR DIFFERENT REGISTER
	EXG D,Y
	ROLD
	EXG D,Y
	ENDM

ADDX MACRO		;MACRO TO ADD NEW INSTRUCTION VARIANT FOR DIFFERENT REGISTER
	EXG D,X
	ADDD \1 \2
	EXG D,X
	ENDM	

ADDY MACRO		;MACRO TO ADD NEW INSTRUCTION VARIANT FOR DIFFERENT REGISTER
	EXG D,Y
	ADDD \1 \2
	EXG D,Y
	ENDM	

ADCD MACRO		;MACRO TO ADD NEW INSTRUCTION VARIANT FOR DIFFERENT REGISTER
	PSHX
	LDX \1 \2
	PSHX
	ADCB 1,SP
	ADCA 0,SP
	PSHD			;SAVE RESULT
	PSHC			;SAVE FLAGS ON STACK
	;AT THIS POINT Z FLAG IS INCORRECT 
	BCLR 0,SP, CCR_Z
	;CLEAR Z ON STACK COPY THEN CORRECT AS NECESSARY
	CMPD #0
	TFR CCR,A			;COPY OF CCR WITH N AND Z CORRECT
	ANDA #CCR_Z	;MASK ONLY N AND Z BITS
	ORAA 0,SP			;OR WITH STACK COPY
	STAA 0,SP			;REPLACE STACK COPY WITH CORRECTED COPY
	PULC				;PLACE CORRECTED FLAGS INTO CCR
	PULD				;RESTORE RESULT TO D	
	PULX				;CLEAR TEMPORARY FROM STACK
	PULX				;RESTORE ORIGINAL X
	ENDM

ADCX MACRO		;MACRO TO ADD NEW INSTRUCTION VARIANT FOR DIFFERENT REGISTER
	EXG D,X
	ADCD
	EXG D,X
	ENDM

ADCY MACRO		;MACRO TO ADD NEW INSTRUCTION VARIANT FOR DIFFERENT REGISTER
	EXG D,Y
	ADCD
	EXG D,Y
	ENDM

SUBX MACRO		;MACRO TO ADD NEW INSTRUCTION VARIANT FOR DIFFERENT REGISTER
	EXG D,X
	SUBD \1 \2
	EXG D,X
	ENDM	

SUBY MACRO		;MACRO TO ADD NEW INSTRUCTION VARIANT FOR DIFFERENT REGISTER
	EXG D,Y
	SUBD \1 \2
	EXG D,Y
	ENDM	

SBCD MACRO		;MACRO TO ADD NEW INSTRUCTION VARIANT FOR DIFFERENT REGISTER
	PSHX
	LDX \1 \2
	PSHX
	SBCB 1,SP
	SBCA 0,SP
	PSHD			;SAVE RESULT
	PSHC			;SAVE FLAGS ON STACK
	;AT THIS POINT Z FLAG IS INCORRECT 
	BCLR 0,SP, CCR_Z
	;CLEAR Z ON STACK COPY THEN CORRECT AS NECESSARY
	CMPD #0
	TFR CCR,A			;COPY OF CCR WITH N AND Z CORRECT
	ANDA #CCR_Z	;MASK ONLY N AND Z BITS
	ORAA 0,SP			;OR WITH STACK COPY
	STAA 0,SP			;REPLACE STACK COPY WITH CORRECTED COPY
	PULC				;PLACE CORRECTED FLAGS INTO CCR
	PULD				;RESTORE RESULT TO D	
	PULX				;CLEAR TEMPORARY FROM STACK
	PULX				;RESTORE ORIGINAL X
	ENDM

SBCX MACRO		;MACRO TO ADD NEW INSTRUCTION VARIANT FOR DIFFERENT REGISTER
	EXG D,X
	SBCD
	EXG D,X
	ENDM

SBCY MACRO		;MACRO TO ADD NEW INSTRUCTION VARIANT FOR DIFFERENT REGISTER
	EXG D,Y
	SBCD
	EXG D,Y
	ENDM

ANDD MACRO		;MACRO TO ADD NEW INSTRUCTION VARIANT FOR DIFFERENT REGISTER
	PSHX
	LDX \1 \2
	PSHX
	ANDB 1,SP
	ANDA 0,SP
	PSHD			;SAVE RESULT
	PSHC			;SAVE FLAGS ON STACK
	;AT THIS POINT Z FLAG IS INCORRECT 
	BCLR 0,SP, CCR_Z
	;CLEAR Z ON STACK COPY THEN CORRECT AS NECESSARY
	CMPD #0
	TFR CCR,A			;COPY OF CCR WITH N AND Z CORRECT
	ANDA #CCR_Z	;MASK ONLY N AND Z BITS
	ORAA 0,SP			;OR WITH STACK COPY
	STAA 0,SP			;REPLACE STACK COPY WITH CORRECTED COPY
	PULC				;PLACE CORRECTED FLAGS INTO CCR
	PULD				;RESTORE RESULT TO D	
	PULX				;CLEAR TEMPORARY FROM STACK
	PULX				;RESTORE ORIGINAL X
	ENDM

ANDX MACRO		;MACRO TO ADD NEW INSTRUCTION VARIANT FOR DIFFERENT REGISTER
	EXG D,X
	ANDD
	EXG D,X
	ENDM

ANDY MACRO		;MACRO TO ADD NEW INSTRUCTION VARIANT FOR DIFFERENT REGISTER
	EXG D,Y
	ANDD
	EXG D,Y
	ENDM

ORD MACRO		;MACRO TO ADD NEW INSTRUCTION VARIANT FOR DIFFERENT REGISTER
	PSHX
	LDX \1 \2
	PSHX
	ORB 1,SP
	ORA 0,SP
	PSHD			;SAVE RESULT
	PSHC			;SAVE FLAGS ON STACK
	;AT THIS POINT Z FLAG IS INCORRECT 
	BCLR 0,SP, CCR_Z
	;CLEAR Z ON STACK COPY THEN CORRECT AS NECESSARY
	CMPD #0
	TFR CCR,A			;COPY OF CCR WITH N AND Z CORRECT
	ANDA #CCR_Z	;MASK ONLY N AND Z BITS
	ORAA 0,SP			;OR WITH STACK COPY
	STAA 0,SP			;REPLACE STACK COPY WITH CORRECTED COPY
	PULC				;PLACE CORRECTED FLAGS INTO CCR
	PULD				;RESTORE RESULT TO D	
	PULX				;CLEAR TEMPORARY FROM STACK
	PULX				;RESTORE ORIGINAL X
	ENDM

ORX MACRO		;MACRO TO ADD NEW INSTRUCTION VARIANT FOR DIFFERENT REGISTER
	EXG D,X
	ORD
	EXG D,X
	ENDM

ORY MACRO		;MACRO TO ADD NEW INSTRUCTION VARIANT FOR DIFFERENT REGISTER
	EXG D,Y
	ORD
	EXG D,Y
	ENDM

EORD MACRO		;MACRO TO ADD NEW INSTRUCTION VARIANT FOR DIFFERENT REGISTER
	PSHX
	LDX \1 \2
	PSHX
	EORB 1,SP
	EORA 0,SP
	PSHD			;SAVE RESULT
	PSHC			;SAVE FLAGS ON STACK
	;AT THIS POINT Z FLAG IS INCORRECT 
	BCLR 0,SP, CCR_Z
	;CLEAR Z ON STACK COPY THEN CORRECT AS NECESSARY
	CMPD #0
	TFR CCR,A			;COPY OF CCR WITH N AND Z CORRECT
	ANDA #CCR_Z	;MASK ONLY N AND Z BITS
	ORAA 0,SP			;OR WITH STACK COPY
	STAA 0,SP			;REPLACE STACK COPY WITH CORRECTED COPY
	PULC				;PLACE CORRECTED FLAGS INTO CCR
	PULD				;RESTORE RESULT TO D	
	PULX				;CLEAR TEMPORARY FROM STACK
	PULX				;RESTORE ORIGINAL X
	ENDM

EORX MACRO		;MACRO TO ADD NEW INSTRUCTION VARIANT FOR DIFFERENT REGISTER
	EXG D,X
	EORD
	EXG D,X
	ENDM

EORY MACRO		;MACRO TO ADD NEW INSTRUCTION VARIANT FOR DIFFERENT REGISTER
	EXG D,Y
	EORD
	EXG D,Y
	ENDM

XORD MACRO		;MACRO TO ADD ALTERNAME MNEMONIC
	EORD \1 \2
	ENDM

XORX MACRO		;MACRO TO ADD ALTERNAME MNEMONIC
	EXG D,X
	XORD
	EXG D,X
	ENDM

XORY MACRO		;MACRO TO ADD ALTERNAME MNEMONIC
	EXG D,Y
	XORD
	EXG D,Y
	ENDM

TSTD MACRO		;MACRO TO ADD NEW INSTRUCTION VARIANT FOR DIFFERENT REGISTER
	CMPD #0
	ENDM

TSTX MACRO		;MACRO TO ADD NEW INSTRUCTION VARIANT FOR DIFFERENT REGISTER
	CMPX #0
	ENDM

TSTY MACRO		;MACRO TO ADD NEW INSTRUCTION VARIANT FOR DIFFERENT REGISTER
	CMPY #0
	ENDM

TSTS MACRO		;MACRO TO ADD NEW INSTRUCTION VARIANT FOR DIFFERENT REGISTER
	CMPS #0
	ENDM

ANDC MACRO		;MACRO TO ADD ALTERNAME MNEMONIC
	ANDCC \1 \2
	ENDM

ORC MACRO		;MACRO TO ADD ALTERNAME MNEMONIC
	ORCC \1 \2
	ENDM

CLRW MACRO		;MACRO TO ADD NEW INSTRUCTION VARIANT FOR WORD LENGTH MEMORY
	MOVW #0, \1 \2
	CCRC CCR_N+CCR_V+CCR_C		;CLRW SHOULD ALWAYS RESULT IN NZVC=0100
	CCRS CCR_Z
	ENDM

LSRW MACRO		;MACRO TO ADD NEW INSTRUCTION VARIANT FOR WORD LENGTH MEMORY
	PSHD
	LDD \1 \2
	LSRD
	PSHC
	STD \1 \2
	PULC
	PULD
	ENDM

ASRW MACRO		;MACRO TO ADD NEW INSTRUCTION VARIANT FOR WORD LENGTH MEMORY
	PSHD
	LDD \1 \2
	ASRD
	PSHC
	STD \1 \2
	PULC
	PULD
	ENDM

LSLW MACRO		;MACRO TO ADD NEW INSTRUCTION VARIANT FOR WORD LENGTH MEMORY
	PSHD
	LDD \1 \2
	LSLD
	PSHC
	STD \1 \2
	PULC
	PULD
	ENDM

ASLW MACRO		;MACRO TO ADD NEW INSTRUCTION VARIANT FOR WORD LENGTH MEMORY
	PSHD
	LDD \1 \2
	ASLD
	PSHC
	STD \1 \2
	PULC
	PULD
	ENDM

RORW MACRO		;MACRO TO ADD NEW INSTRUCTION VARIANT FOR WORD LENGTH MEMORY
	PSHD
	LDD \1 \2
	RORD
	PSHC
	STD \1 \2
	PULC
	PULD
	ENDM

ROLW MACRO		;MACRO TO ADD NEW INSTRUCTION VARIANT FOR WORD LENGTH MEMORY
	PSHD
	LDD \1 \2
	ROLD
	PSHC
	STD \1 \2
	PULC
	PULD
	ENDM

INCW MACRO		;MACRO TO ADD NEW INSTRUCTION VARIANT FOR WORD LENGTH MEMORY
	PSHD
	LDD #1
	ADDD \1 \2
	PSHC
	STD \1 \2
	PULC
	PULD
	ENDM

DECW MACRO		;MACRO TO ADD NEW INSTRUCTION VARIANT FOR WORD LENGTH MEMORY
	PSHD
	LDD \1 \2
	SUBD #1
	PSHC
	STD \1 \2
	PULC
	PULD
	ENDM

COMW MACRO		;MACRO TO ADD NEW INSTRUCTION VARIANT FOR WORD LENGTH MEMORY
	PSHD
	LDD \1 \2
	COMD
	PSHC
	STD \1 \2
	PULC
	PULD
	ENDM

NOTW MACRO		;MACRO TO ADD NEW INSTRUCTION VARIANT FOR WORD LENGTH MEMORY
	PSHD
	LDD \1 \2
	NOTD
	PSHC
	STD \1 \2
	PULC
	PULD
	ENDM

NEGW MACRO		;MACRO TO ADD NEW INSTRUCTION VARIANT FOR WORD LENGTH MEMORY
	PSHD
	LDD \1 \2
	NEGD
	PSHC
	STD \1 \2
	PULC
	PULD
	ENDM

TSTW MACRO		;MACRO TO ADD NEW INSTRUCTION VARIANT FOR WORD LENGTH MEMORY
	PSHD
	LDD \1 \2
	TSTD
	PULD
	ENDM
	
CPA MACRO		;MACRO TO ADD ALTERNAME MNEMONIC
	CMPA \1 \2
	ENDM

CPB MACRO		;MACRO TO ADD ALTERNAME MNEMONIC
	CMPB \1 \2
	ENDM

INA MACRO		;MACRO TO ADD ALTERNAME MNEMONIC
	INCA 
	ENDM

INB MACRO		;MACRO TO ADD ALTERNAME MNEMONIC
	INCB
	ENDM

IND MACRO		;MACRO TO ADD ALTERNAME MNEMONIC
	INCD
	ENDM

DEA	MACRO		;MACRO TO ADD ALTERNAME MNEMONIC
	DECA
	ENDM

DEB MACRO		;MACRO TO ADD ALTERNAME MNEMONIC
	DECB
	ENDM

DED MACRO		;MACRO TO ADD ALTERNAME MNEMONIC
	DECD
	ENDM

SBX MACRO	;MACRO TO ADD NEW INSTRUCTION VARIANT FOR DIFFERENT REGISTER
	NEGB
	ABX
	PSHC
	NEGB
	PULC
	ENDM

SBY MACRO	;MACRO TO ADD NEW INSTRUCTION VARIANT FOR DIFFERENT REGISTER
	NEGB
	ABY
	PSHC
	NEGB
	PULC
	ENDM

LDC MACRO	;MACRO TO ADD NEW INSTRUCTION VARIANT FOR DIFFERENT REGISTER
	PSHA
	LDAA \1 \2
	TFR A,CCR
	PULA
	ENDM

STC MACRO	;MACRO TO ADD NEW INSTRUCTION VARIANT FOR DIFFERENT REGISTER
	PSHA
	PSHC
	TFR CCR,A
	STAA \1 \2
	PULC
	PULA
	ENDM

CCRS MACRO		;CONDITION CODE SET WITH MASK
	PSHC
	BSET 0,SP, \1
	PULC
	ENDM

CCRC MACRO 		;CONDITION CODE CLEAR WITH MASK
	PSHC
	BCLR 0,SP, \1
	PULC
	ENDM
	


SPI0_BAUD	MACRO ;BAUD_DIVISOR
;SPI BAUD RATE IS 24MHZ/BAUD DIVISOR
;BAUD DIVISOR IS (UPPER 4 BITS + 1) * 2^ (LOWER 4-BITS + 1)
#IF \# = 0
BAUD_DIVISOR_\@	EQU	$22	;DEFAULT BAUD RATE IS 1 MBPS
#MSG "NO BAUD RATE SPECIFIED, USING $22 (-> 1MBPS) FOR DEFAULT"
#ENDIF
#IF \# > 0
BAUD_DIVISOR_\@	EQU	\1	;FIRST PARAMETER IS BAUD RATE
#ENDIF
	MOVB #BAUD_DIVISOR_\@, SPI0BR
#IF \# >1
#MSG "MACRO SPI0_BAUD EXPECTS EITHER AT MOST 1 PARAMETER WHICH WILL RESOLVE TO A BAUD RATE DIVISOR"
#MSG "IF NO PARAMETER IS SPECIFIED, THEN THE DEFAULT DIVISOR OF $22 (-> 1MBPS) IS USED"
#ENDIF
	ENDM

SPI0_ENABLE	MACRO 
	BSET SPI0CR1,SPI_SPE	
	ENDM

SPI0_DISABLE	MACRO 
	BCLR SPI0CR1,SPI_SPE	
	ENDM

SPI0_MASTER	MACRO
	BSET SPI0CR1,SPI_MSTR
	ENDM

SPI0_SLAVE	MACRO
	BCLR SPI0CR1,SPI_MSTR
	ENDM

SPI0_LSB_FIRST	MACRO
	BSET SPI0CR1,SPI_LSBFE
	ENDM

SPI0_MSB_FIRST	MACRO
	BCLR SPI0CR1,SPI_LSBFE
	ENDM

SPI0_CPOL	MACRO	;CPOL
#IF \# < 1
CPOL\@	EQU 0
ELSE
CPOL\@	EQU \1
#ENDIF
#IF CPOL\@ = 0
	BCLR SPI0CR1,SPI_CPOL
#ENDIF
#IF CPOL\@ = 1
	BSET SPI0CR1,SPI_CPOL
#ENDIF
#IF CPOL\@ > 1
	BCLR SPI0CR1,SPI_CPOL
#WARN "SPI0 CPOL MUST BE 0 OR 1, DEFAULTING TO 0"
#ENDIF
	ENDM

SPI0_CPHA	MACRO	;CPHA
#IF \# < 1
CPHA\@	EQU 0
ELSE
CPHA\@	EQU \1
#ENDIF
#IF CPHA\@ = 0
	BCLR SPI0CR1,SPI_CPHA
#ENDIF
#IF CPHA\@ = 1
	BSET SPI0CR1,SPI_CPHA
#ENDIF
#IF CPHA\@ > 1
	BCLR SPI0CR1,SPI_CPHA
#WARN "SPI0 CPHA MUST BE 0 OR 1, DEFAULTING TO 0"
#ENDIF
	ENDM


SPI0_SETUP	MACRO	;BAUD, CPOL, CPHA
	SPI0_BAUD \1
	SPI0_MASTER
	SPI0_MSB_FIRST
	SPI0_CPOL \2	
	SPI0_CPHA \3
	SPI0_ENABLE
	ENDM

SPI1_BAUD	MACRO ;BAUD_DIVISOR
;SPI BAUD RATE IS 24MHZ/BAUD DIVISOR
;BAUD DIVISOR IS (UPPER 4 BITS + 1) * 2^ (LOWER 4-BITS + 1)
#IF \# = 0
BAUD_DIVISOR_\@	EQU	$22	;DEFAULT BAUD RATE IS 1 MBPS
#MSG "NO BAUD RATE SPECIFIED, USING $22 (-> 1MBPS) FOR DEFAULT"
#ENDIF
#IF \# > 0
BAUD_DIVISOR_\@	EQU	\1	;FIRST PARAMETER IS BAUD RATE
#ENDIF
	MOVB #BAUD_DIVISOR_\@, SPI1BR
#IF \# >1
#MSG "MACRO SPI1_BAUD EXPECTS EITHER AT MOST 1 PARAMETER WHICH WILL RESOLVE TO A BAUD RATE DIVISOR"
#MSG "IF NO PARAMETER IS SPECIFIED, THEN THE DEFAULT DIVISOR OF $22 (-> 1MBPS) IS USED"
#ENDIF
	ENDM

SPI1_ENABLE	MACRO 
	BSET SPI1CR1,SPI_SPE
	ENDM	

SPI1_DISABLE	MACRO 
	BCLR SPI1CR1,SPI_SPE	
	ENDM

SPI1_MASTER	MACRO
	BSET SPI1CR1,SPI_MSTR
	ENDM

SPI1_SLAVE	MACRO
	BCLR SPI1CR1,SPI_MSTR
	ENDM

SPI1_LSB_FIRST	MACRO
	BSET SPI1CR1,SPI_LSBFE
	ENDM

SPI1_MSB_FIRST	MACRO
	BCLR SPI1CR1,SPI_LSBFE
	ENDM

SPI1_CPOL	MACRO	;CPOL
#IF \# < 1
CPOL\@	EQU 0
ELSE
CPOL\@	EQU \1
#ENDIF
#IF CPOL\@ = 0
	BCLR SPI1CR1,SPI_CPOL
#ENDIF
#IF CPOL\@ = 1
	BSET SPI1CR1,SPI_CPOL
#ENDIF
#IF CPOL\@ > 1
	BCLR SPI1CR1,SPI_CPOL
#WARN "SPI1 CPOL MUST BE 0 OR 1, DEFAULTING TO 0"
#ENDIF
	ENDM

SPI1_CPHA	MACRO	;CPHA
#IF \# < 1
CPHA\@	EQU 0
ELSE
CPHA\@	EQU \1
#ENDIF
#IF CPHA\@ = 0
	BCLR SPI1CR1,SPI_CPHA
#ENDIF
#IF CPHA\@ = 1
	BSET SPI1CR1,SPI_CPHA
#ENDIF
#IF CPHA\@ > 1
	BCLR SPI1CR1,SPI_CPHA
#WARN "SPI1 CPHA MUST BE 0 OR 1, DEFAULTING TO 0"
#ENDIF
	ENDM


SPI1_SETUP	MACRO	;BAUD, CPOL, CPHA
	SPI1_BAUD \1
	SPI1_MASTER
	SPI1_MSB_FIRST
	SPI1_CPOL \2	
	SPI1_CPHA \3
	SPI1_ENABLE
	ENDM

SET_SYSTEM_CLOCK MACRO
;WHEN STARTING FROM EEPROM OFR FLASH, THE PLL CLOCK MUST BE INITIALIZED OR THE SYSTEM CLOCK RATE WILL DEFAULT TO
;1/2 OF THE CRYSTAL OSCILLATOR FREQUENCY
;THE CRYSTAL OSCILLATOR ION THE DRAGON12 IS 4MHZ
;THE CRYSTAL OSCILLATOR ON THE DRAGON12PLUS IS 8MHZ
;THE CRYSTAL OSCILLATOR ON THE MMINIDRAGON/MINIDRAGONPLUS IS 16MHZ

;TO SET THE PLL CLOCK:
;        
;       PLLCLK = CrystalFreq * 2 * (SYNR+1) / (REFDV+1)
;       
;       If CrystalFreq = 4Mhz on DRAGON12 board
;         SYNR     = 5    PLL multiplier will be 6
;         REFDV    = 0    PLL divisor will be 1

;       If CrystalFreq = 8Mhz on DRAGON12PLUS board
;         SYNR     = 5    PLL multiplier will be 6
;         REFDV    = 1    PLL divisor will be 2

;       If CrystalFreq = 16Mhz on MINIDRAGON board
;         SYNR     = 5    PLL multiplier will be 6
;         REFDV    = 3    PLL divisor will be 4

;NOTE CRYSTAL_KHZ IS DEFINED BY THE HC12TOOLS LIBRARY
#IFDEF PLL_DIVISOR
#WARN "PLL_DIVISOR PREDEFINED.  CLOCK RATE UNKNOWN!"
#ENDIF

#IFNDEF PLL_DIVISOR
#IF CRYSTAL_KHZ = 4000
PLL_DIVISOR EQU 0
#ELIF CRYSTAL_KHZ = 8000
PLL_DIVISOR EQU 1
#ELIF CRYSTAL_KHZ = 16000
PLL_DIVISOR EQU 3
#ENDIF
#ENDIF

#IFNDEF PLL_DIVISOR
#WARN "PLL_DIVISOR UNDEFINED.  CLOCK RATE UNKNOWN!"
#FAIL
#ENDIF

;       PLLCLK = 4*2*6/1 = 48MHz
;       The bus speed = PLLCLK / 2 = 24 MHz
;
;      
;********PLL code for 24MHz bus speed from a 4/8/16 crystal
	SEI
	BCLR CLKSEL,CLKSEL_PLLSEL	;CLOCK IS DERIVED FROM OSCILLATOR
	BSET PLLCTL,PLLCTL_PLLON	;TURN ON PLL
	MOVB #5,SYNR			;MULTIPLIER IS 5+1=6
	MOVB #PLL_DIVISOR,REFDV	;USE 3 FOR 16MHZ, 1 FOR 8MHZ, 0 FOR 4 MHZ
	BRCLR CRGFLG,CRGFLG_LOCK,*	;WAIT UNTIL FLAG INDICATES PLL IS LOCKED ONTO FREQUENCY
	BSET CLKSEL,CLKSEL_PLLSEL	;CLOCK IS DERIVED FROM PLL
	ENDM

	LIST